{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Wagtail Live Wagtail Live is a Wagtail CMS package to create live blog pages. About With Wagtail Live: Reporters can instantly publish to a live blog by submitting messages via mobile apps. Audience can read the posts right away as the live blog page instantly updates. Content editors can edit messages via the Wagtail Admin. The internal format is a normal Wagtail page with streamfield and blocks. Create, update, delete operations. Rich text, images, emojis, URLs are converted to embeds. Slack and a Live blog page: Content is also editable via the Wagtail admin: Compatibility Wagtail Live works with: Wagtail 2.12 or higher Django 2.2 or higher Python 3.7 or higher Getting started To get started with Wagtail Live, check out the Wagtail Live tutorial . Documentation All documentation is in the \"docs\" directory and online at wagtail.github.io/wagtail-live/ . Community We have a wagtail-live channel in Wagtail's Slack workspace for discussions about the project. Contributing - Testing To contribute to Wagtail Live or run the test suite, refer to the development section of the docs. Google Summer of Code This project is part of Google Summer of Code 2021 by Tidiane Dia. Check out the GSOC report . Sponsors Wagtail-live provides a publisher based on PieSocket . PieSocket offers a 'free-plus' plan to all our users. See the link above for details.","title":"Home"},{"location":"#wagtail-live","text":"Wagtail Live is a Wagtail CMS package to create live blog pages.","title":"Wagtail Live"},{"location":"#about","text":"With Wagtail Live: Reporters can instantly publish to a live blog by submitting messages via mobile apps. Audience can read the posts right away as the live blog page instantly updates. Content editors can edit messages via the Wagtail Admin. The internal format is a normal Wagtail page with streamfield and blocks. Create, update, delete operations. Rich text, images, emojis, URLs are converted to embeds. Slack and a Live blog page: Content is also editable via the Wagtail admin:","title":"About"},{"location":"#compatibility","text":"Wagtail Live works with: Wagtail 2.12 or higher Django 2.2 or higher Python 3.7 or higher","title":"Compatibility"},{"location":"#getting-started","text":"To get started with Wagtail Live, check out the Wagtail Live tutorial .","title":"Getting started"},{"location":"#documentation","text":"All documentation is in the \"docs\" directory and online at wagtail.github.io/wagtail-live/ .","title":"Documentation"},{"location":"#community","text":"We have a wagtail-live channel in Wagtail's Slack workspace for discussions about the project.","title":"Community"},{"location":"#contributing-testing","text":"To contribute to Wagtail Live or run the test suite, refer to the development section of the docs.","title":"Contributing - Testing"},{"location":"#google-summer-of-code","text":"This project is part of Google Summer of Code 2021 by Tidiane Dia. Check out the GSOC report .","title":"Google Summer of Code"},{"location":"#sponsors","text":"Wagtail-live provides a publisher based on PieSocket . PieSocket offers a 'free-plus' plan to all our users. See the link above for details.","title":"Sponsors"},{"location":"development/","text":"Development Install this package in development mode: git clone git@github.com:wagtail/wagtail-live.git cd wagtail-live With your preferred virtualenv activated, install the package in development mode with the included testing and documentation dependencies: python -m pip install -e '.[test,docs]' -U Testing Run the test suite locally: pytest Or test all supported configurations using tox: python -m pip install tox tox Code style linting Check the code style of all files (requires GNU Make to be installed): make lint Fix any errors that can be automatically fixed: make format Documentation Run documentation locally: mkdocs serve Deploy documentation to Github pages: mkdocs gh-deploy Releasing new versions This package follows SemVer . Please keep SemVer in mind when updating the version number in src/wagtail_live/__init__.py . Building the package & publishing to PyPI Make sure you install the build extra before attempting to make a release: pip install -e '.[build]' This project comes with a helper script that assists in making a release. ./make_release.sh This script will: Verify that no git tag exists for the current version number. Build wheel and source distributions. Show instructions on how to create a git tag. Show instructions on how to upload to PyPI.","title":"Development"},{"location":"development/#development","text":"Install this package in development mode: git clone git@github.com:wagtail/wagtail-live.git cd wagtail-live With your preferred virtualenv activated, install the package in development mode with the included testing and documentation dependencies: python -m pip install -e '.[test,docs]' -U","title":"Development"},{"location":"development/#testing","text":"Run the test suite locally: pytest Or test all supported configurations using tox: python -m pip install tox tox","title":"Testing"},{"location":"development/#code-style-linting","text":"Check the code style of all files (requires GNU Make to be installed): make lint Fix any errors that can be automatically fixed: make format","title":"Code style linting"},{"location":"development/#documentation","text":"Run documentation locally: mkdocs serve Deploy documentation to Github pages: mkdocs gh-deploy","title":"Documentation"},{"location":"development/#releasing-new-versions","text":"This package follows SemVer . Please keep SemVer in mind when updating the version number in src/wagtail_live/__init__.py .","title":"Releasing new versions"},{"location":"development/#building-the-package-publishing-to-pypi","text":"Make sure you install the build extra before attempting to make a release: pip install -e '.[build]' This project comes with a helper script that assists in making a release. ./make_release.sh This script will: Verify that no git tag exists for the current version number. Build wheel and source distributions. Show instructions on how to create a git tag. Show instructions on how to upload to PyPI.","title":"Building the package &amp; publishing to PyPI"},{"location":"gsoc_report/","text":"Google Summer of Code 2021 report The goal of the Wagtail Live project was to propose a flexible open-source liveblogging tool. A live blog is a blog providing real-time updates on an ongoing event. As part of the GSOC program, my mentors and I have spent summer (June-August) 2021 working on it. This report aims to give an overview of the work done during that period. Design As a blogging tool, Wagtail Live cares about how a blogger manages content. In addition to the Wagtail admin that provides a smooth but less mobile-friendly editing interface, Wagtail Live gives a blogger the ability to use a messaging app like Slack, Telegram, Whatsapp to write blog posts. Wagtail Live can be divided into three major components: Receivers A receiver is a bridge between a messaging app and a Wagtail Live page. It receives updates from the messaging app, decodes them, and saves them on the corresponding live page. LivePageMixin LivePageMixin is the base model for live pages. Publishers A publisher is a bridge between a Wagtail Live page and web clients. It delivers new/edited/deleted posts of a page to web clients viewing the page live. Implementation Milestone 1: Build a basic but working version of Wagtail Live Added block types Added LivePageMixin class . Implemented a base receiver class and a Slack receiver Implemented WebhookReceiverMixin . Added publishers using the polling technique . At that point, Wagtail Live could be used with Slack and interval/long polling publishers. Milestone 2: More publishers and receivers This milestone involved adding more publishers and receivers. Added Telegram webhook receiver . Added a publisher based on channels Added publishers based on websockets and starlette Added a PieSocket publisher . Webapp Initially, we wanted to provide a debugging tool, Wagtail Live debug , to avoid setting up a messaging app in the development phase. However, we finally settled on proposing a complete alternative to messaging apps. The webapp is based on Django Rest Framework and will propose a user interface. A blogger can use both the webapp interface and the webapp API to manage content. Related PRs: Wagtail Live debug Renamed wagtail_live_debug to wagtail_live_interface Wagtail Live Interface Receiver Renamed wagtail_live_interface to webapp Add image support to webapp It's still a work in progress. Related Issues: API receiver - webapp authentication webapp documentation Current state of the project We've met most of the expectations outlined in the initial proposal. However, there is still some work to do. I have opened issues decribing what's left. We would like to have more users try Wagtail Live and give us feedback. It would also be nice to have new contributors add more receivers/publishers. Tests and documentation We added documentation and tests for most of the functionalities proposed. The documentation is available at https://wagtail.github.io/wagtail-live/ . From this PR , the project is 100% covered. Tests can be found in the tests module here . Talks I was asked to present the project at the What's New in Wagtail webinar. The recording can be found here . I'm also delivering a talk at the Djangocon US conference , which will take place on October 21-23, 2021. Feelings From technical skills to soft skills, I've learned a lot in this project. To name a few: Django and Wagtail internals asynchronous programming websocket protocol pytest package releasing Github actions I thank my excellent mentors who have also contributed a lot to the project besides their guidance: Coen van Der Kamp @allcaps Tom Dyson @tomdyson Lucas Moeskops @lucasmoeskops Storm Heg @stormheg We have also received nice help from Nick Lee (Senior designer at Torchbox) and Andy Babic @ababic . Links Github page PyPI Wagtail Live proposal GSOC project page","title":"GSOC report"},{"location":"gsoc_report/#google-summer-of-code-2021-report","text":"The goal of the Wagtail Live project was to propose a flexible open-source liveblogging tool. A live blog is a blog providing real-time updates on an ongoing event. As part of the GSOC program, my mentors and I have spent summer (June-August) 2021 working on it. This report aims to give an overview of the work done during that period.","title":"Google Summer of Code 2021 report"},{"location":"gsoc_report/#design","text":"As a blogging tool, Wagtail Live cares about how a blogger manages content. In addition to the Wagtail admin that provides a smooth but less mobile-friendly editing interface, Wagtail Live gives a blogger the ability to use a messaging app like Slack, Telegram, Whatsapp to write blog posts. Wagtail Live can be divided into three major components: Receivers A receiver is a bridge between a messaging app and a Wagtail Live page. It receives updates from the messaging app, decodes them, and saves them on the corresponding live page. LivePageMixin LivePageMixin is the base model for live pages. Publishers A publisher is a bridge between a Wagtail Live page and web clients. It delivers new/edited/deleted posts of a page to web clients viewing the page live.","title":"Design"},{"location":"gsoc_report/#implementation","text":"","title":"Implementation"},{"location":"gsoc_report/#milestone-1-build-a-basic-but-working-version-of-wagtail-live","text":"Added block types Added LivePageMixin class . Implemented a base receiver class and a Slack receiver Implemented WebhookReceiverMixin . Added publishers using the polling technique . At that point, Wagtail Live could be used with Slack and interval/long polling publishers.","title":"Milestone 1: Build a basic but working version of Wagtail Live"},{"location":"gsoc_report/#milestone-2-more-publishers-and-receivers","text":"This milestone involved adding more publishers and receivers. Added Telegram webhook receiver . Added a publisher based on channels Added publishers based on websockets and starlette Added a PieSocket publisher .","title":"Milestone 2: More publishers and receivers"},{"location":"gsoc_report/#webapp","text":"Initially, we wanted to provide a debugging tool, Wagtail Live debug , to avoid setting up a messaging app in the development phase. However, we finally settled on proposing a complete alternative to messaging apps. The webapp is based on Django Rest Framework and will propose a user interface. A blogger can use both the webapp interface and the webapp API to manage content. Related PRs: Wagtail Live debug Renamed wagtail_live_debug to wagtail_live_interface Wagtail Live Interface Receiver Renamed wagtail_live_interface to webapp Add image support to webapp It's still a work in progress. Related Issues: API receiver - webapp authentication webapp documentation","title":"Webapp"},{"location":"gsoc_report/#current-state-of-the-project","text":"We've met most of the expectations outlined in the initial proposal. However, there is still some work to do. I have opened issues decribing what's left. We would like to have more users try Wagtail Live and give us feedback. It would also be nice to have new contributors add more receivers/publishers.","title":"Current state of the project"},{"location":"gsoc_report/#tests-and-documentation","text":"We added documentation and tests for most of the functionalities proposed. The documentation is available at https://wagtail.github.io/wagtail-live/ . From this PR , the project is 100% covered. Tests can be found in the tests module here .","title":"Tests and documentation"},{"location":"gsoc_report/#talks","text":"I was asked to present the project at the What's New in Wagtail webinar. The recording can be found here . I'm also delivering a talk at the Djangocon US conference , which will take place on October 21-23, 2021.","title":"Talks"},{"location":"gsoc_report/#feelings","text":"From technical skills to soft skills, I've learned a lot in this project. To name a few: Django and Wagtail internals asynchronous programming websocket protocol pytest package releasing Github actions I thank my excellent mentors who have also contributed a lot to the project besides their guidance: Coen van Der Kamp @allcaps Tom Dyson @tomdyson Lucas Moeskops @lucasmoeskops Storm Heg @stormheg We have also received nice help from Nick Lee (Senior designer at Torchbox) and Andy Babic @ababic .","title":"Feelings"},{"location":"gsoc_report/#links","text":"Github page PyPI Wagtail Live proposal GSOC project page","title":"Links"},{"location":"background-information/input-sources-and-receivers/","text":"Input sources and receivers Wagtail Live can receive messages from various input sources. Slack and Telegram are supported. An API and web application are in development. Each input source has a receiver class. This class handles the incoming message, converts it to Streamfield blocks and stores it on the live blog page. Not all input sources support all actions: Action Slack Telegram Post message \u2705 \u2705 Update message \u2705 \u2705 Delete message \u2705 \u274c 1 Post image \u2705 \u2705 Update image \u2705 \u2705 Delete image \u2705 \u274c 2 Embed \u2705 \u2705 Emoji \u2705 \u2705 1,2 Telegram does not call the webhook on delete. Note In the Wagtail admin interface, you can edit messages. A message update is published to your live page automatically. A message update does not update the input source. Slack or Telegram still display the old message.","title":"Receivers"},{"location":"background-information/input-sources-and-receivers/#input-sources-and-receivers","text":"Wagtail Live can receive messages from various input sources. Slack and Telegram are supported. An API and web application are in development. Each input source has a receiver class. This class handles the incoming message, converts it to Streamfield blocks and stores it on the live blog page. Not all input sources support all actions: Action Slack Telegram Post message \u2705 \u2705 Update message \u2705 \u2705 Delete message \u2705 \u274c 1 Post image \u2705 \u2705 Update image \u2705 \u2705 Delete image \u2705 \u274c 2 Embed \u2705 \u2705 Emoji \u2705 \u2705 1,2 Telegram does not call the webhook on delete. Note In the Wagtail admin interface, you can edit messages. A message update is published to your live page automatically. A message update does not update the input source. Slack or Telegram still display the old message.","title":"Input sources and receivers"},{"location":"background-information/publishers/","text":"What publisher is right for you? Wagtail Live supports various publishers. Their task is to update the live page every time a post is created. Interval polling Interval polling is Javascript running in the browser, that asks the webserver for updates with a regular interval. Wagtail Live has a configurable interval, the default is 3 seconds. This value is typically between seconds and a couple of minutes. Even if there are no new posts, the request is made. This is server-resource heavy and doesn't scale well. \u2795 Easy to set up Normal HTTP protocol \u2796 Can take up to the interval time for a post to appear Server resource-heavy Does not scale Use interval polling on low-traffic websites, and when update delay isn't an issue. Set up interval polling Long polling Long polling is a bit like interval polling. The difference is that the server keeps the connection open for the interval time. This way, there is always an open connection. Updates can be sent the moment they are created. Updates appear instantaneous. \u2795 Easy to set up Instant updates Normal HTTP protocol \u2796 Server resource-heavy Does not scale Server can only handle a finite amount of connections Use long polling for low-volume sites, evaluation, and demonstration purposes. Set up long polling WebSocket A WebSocket is the better choice. Wagtail Live supports multiple ways to set up a WebSocket. Traditionally, Python applications (like Django/Wagtail) use the Web Server Gateway Interface ( WSGI ) to communicate between application and server. HTTP and WSGI are designed to handle a request response cycle. A browser requests an URL, the webserver serves the response. One at the time. This kind of setup is event based. It only does something when a request comes in, and idles for the rest of the time. The WebSocket protocol is more advanced, lightweight and server resource friendly. It allows a persistent connection between server and browser. It is set up once and used for a long time. Communication is full-duplex. Messages can be sent from server to browser, and the other way around. This kind of setup runs an event loop and handles messages as they occur. Note that we talk about messages and not request/response. A message doesn't have a response. Maybe a message triggers the application to send another message. But, in the meantime, other messages can be sent and received. It is asynchronous. To use the WebSocket protocol, the server and applications need support asynchronous communications. \u2795 Lightweight on server resources Persistent connection Instant updates Handles many users \u2796 Takes more effort to set up Note Websockets are full-duplex. However, Wagtail Live only sends messages to the browser. Piesocket Piesocket is software-as-a-service. Run your Django/Wagtail application like normal. Use Piesocket to handle the WebSocket. Create an account, set up the credentials, and you are ready to go. Set up Piesocket Django Channels With Django Channels , you'll have a single application handling both HTTP and WS protocols. Django Channels runs your application over ASGI and requires Daphne . Daphne is a pure-Python ASGI server, maintained by members of the Django project. Set up Django Channels Starlette Starlette is a lightweight toolkit for building high-performance WebSocket service. You need to run a ASGI server, such as Uvicorn , Daphne , or Hypercorn . Start both the ASGI server for the Websocket and your Django/Wagtail application. Set up Starlette Websockets Websockets is a library for building WebSocket server. It is built on top of Asyncio, Python\u2019s standard asynchronous I/O framework. Start both the Websockets server for the Websocket and your Django/Wagtail application. Set up Websockets","title":"Publishers"},{"location":"background-information/publishers/#what-publisher-is-right-for-you","text":"Wagtail Live supports various publishers. Their task is to update the live page every time a post is created.","title":"What publisher is right for you?"},{"location":"background-information/publishers/#interval-polling","text":"Interval polling is Javascript running in the browser, that asks the webserver for updates with a regular interval. Wagtail Live has a configurable interval, the default is 3 seconds. This value is typically between seconds and a couple of minutes. Even if there are no new posts, the request is made. This is server-resource heavy and doesn't scale well. \u2795 Easy to set up Normal HTTP protocol \u2796 Can take up to the interval time for a post to appear Server resource-heavy Does not scale Use interval polling on low-traffic websites, and when update delay isn't an issue. Set up interval polling","title":"Interval polling"},{"location":"background-information/publishers/#long-polling","text":"Long polling is a bit like interval polling. The difference is that the server keeps the connection open for the interval time. This way, there is always an open connection. Updates can be sent the moment they are created. Updates appear instantaneous. \u2795 Easy to set up Instant updates Normal HTTP protocol \u2796 Server resource-heavy Does not scale Server can only handle a finite amount of connections Use long polling for low-volume sites, evaluation, and demonstration purposes. Set up long polling","title":"Long polling"},{"location":"background-information/publishers/#websocket","text":"A WebSocket is the better choice. Wagtail Live supports multiple ways to set up a WebSocket. Traditionally, Python applications (like Django/Wagtail) use the Web Server Gateway Interface ( WSGI ) to communicate between application and server. HTTP and WSGI are designed to handle a request response cycle. A browser requests an URL, the webserver serves the response. One at the time. This kind of setup is event based. It only does something when a request comes in, and idles for the rest of the time. The WebSocket protocol is more advanced, lightweight and server resource friendly. It allows a persistent connection between server and browser. It is set up once and used for a long time. Communication is full-duplex. Messages can be sent from server to browser, and the other way around. This kind of setup runs an event loop and handles messages as they occur. Note that we talk about messages and not request/response. A message doesn't have a response. Maybe a message triggers the application to send another message. But, in the meantime, other messages can be sent and received. It is asynchronous. To use the WebSocket protocol, the server and applications need support asynchronous communications. \u2795 Lightweight on server resources Persistent connection Instant updates Handles many users \u2796 Takes more effort to set up Note Websockets are full-duplex. However, Wagtail Live only sends messages to the browser.","title":"WebSocket"},{"location":"background-information/publishers/#piesocket","text":"Piesocket is software-as-a-service. Run your Django/Wagtail application like normal. Use Piesocket to handle the WebSocket. Create an account, set up the credentials, and you are ready to go. Set up Piesocket","title":"Piesocket"},{"location":"background-information/publishers/#django-channels","text":"With Django Channels , you'll have a single application handling both HTTP and WS protocols. Django Channels runs your application over ASGI and requires Daphne . Daphne is a pure-Python ASGI server, maintained by members of the Django project. Set up Django Channels","title":"Django Channels"},{"location":"background-information/publishers/#starlette","text":"Starlette is a lightweight toolkit for building high-performance WebSocket service. You need to run a ASGI server, such as Uvicorn , Daphne , or Hypercorn . Start both the ASGI server for the Websocket and your Django/Wagtail application. Set up Starlette","title":"Starlette"},{"location":"background-information/publishers/#websockets","text":"Websockets is a library for building WebSocket server. It is built on top of Asyncio, Python\u2019s standard asynchronous I/O framework. Start both the Websockets server for the Websocket and your Django/Wagtail application. Set up Websockets","title":"Websockets"},{"location":"getting_started/tutorial/","text":"Wagtail Live Tutorial This tutorial describes how to build a live blog with Wagtail Live. Install and run Wagtail Live Create and activate a virtual environment We recommend using a virtual environment, which isolates installed dependencies from other projects. This tutorial uses venv , which is packaged with Python 3. Create a new virtual environment by running: On Windows (cmd.exe): > python3 -m venv livesite\\livesite > livesite\\livesite\\Scripts\\activate.bat On GNU/Linux or MacOS (bash): $ python3 -m venv livesite/livesite $ source livesite/livesite/bin/activate For other shells see the venv documentation . Install Wagtail Live and other dependencies Use pip to install Wagtail and Wagtail Live: $ python -m pip install wagtail $ python -m pip install wagtail-live Generate your site Because the folder livesite was already created by venv , run wagtail start with an additional argument to specify the destination directory: $ wagtail start livesite livesite Create your first live page Start a new liveblog app: $ cd livesite $ python3 manage.py startapp liveblog You will then need to add wagtail_live and liveblog to your INSTALLED_APPS in your settings.base file: INSTALLED_APPS = [ 'home' , 'search' , 'liveblog' , 'wagtail_live' , ... # Other apps ] We can now create our first LiveBlogPage . Add the following in liveblog.models : from wagtail.core.models import Page from wagtail_live.models import LivePageMixin class LiveBlogPage ( Page , LivePageMixin ): content_panels = Page . content_panels + LivePageMixin . panels We'll need to specify the path to our live page model as the value of the WAGTAIL_LIVE_PAGE_MODEL setting: WAGTAIL_LIVE_PAGE_MODEL = \"liveblog.models.LiveBlogPage\" Create a templates folder inside your liveblog app. Add a liveblog folder in the templates folder that you just created and create a live_blog_page.html file. This represents our LiveBlogPage template. For now, add this to your live_blog_page.html template: { % include \"wagtail_live/live_posts.html\" % } That's all we need in our models. Configuring a publisher The goal of publishers is to \"publish\" new updates to the frontend/client side. Choose and configure a publisher from the following list: Long Polling: Set up long polling publisher Interval Polling: Set up interval polling publisher Django channels: Set up Django channels publisher PieSocket: Set up PieSocket publisher Websockets: Set up websockets publisher Starlette: Set up starlette publisher Configure an input source and its corresponding receiver We need an input source for our live blog. An input source is a platform (often a messaging app, but any other tool that allows content editing and offers an API can be used) where we edit the content that appears on the front-end/client side. We also need a receiver for our input source. The goal of a receiver is to receive/retrieve updates from an input source. Choose an input source from the following list and configure its corresponding receiver: Slack: Setup Slack Events API receiver Telegram: Setup Telegram webhook receiver That's it for the configuration part. Create the database Finally, let's create our tables and an admin user: $ python3 manage.py makemigrations $ python3 manage.py migrate $ python3 manage.py createsuperuser When logged into the admin site, a superuser has full permissions and is able to view/create/manage the database. Liveblogging Start the development server as following: $ python3 manage.py runserver Go to http://127.0.0.1:8000/admin/ and create a new page of type LiveBlogPage . You can choose the title you like for the page and fill the channel_id field with the ID of the channel you created in the input source chosen (Slack/Telegram). Click on the Live button to display the page. Enter the channel you created in the input source chosen and start posting. You should see your posts in the page momentarily!","title":"Tutorial"},{"location":"getting_started/tutorial/#wagtail-live-tutorial","text":"This tutorial describes how to build a live blog with Wagtail Live.","title":"Wagtail Live Tutorial"},{"location":"getting_started/tutorial/#install-and-run-wagtail-live","text":"","title":"Install and run Wagtail Live"},{"location":"getting_started/tutorial/#create-and-activate-a-virtual-environment","text":"We recommend using a virtual environment, which isolates installed dependencies from other projects. This tutorial uses venv , which is packaged with Python 3. Create a new virtual environment by running: On Windows (cmd.exe): > python3 -m venv livesite\\livesite > livesite\\livesite\\Scripts\\activate.bat On GNU/Linux or MacOS (bash): $ python3 -m venv livesite/livesite $ source livesite/livesite/bin/activate For other shells see the venv documentation .","title":"Create and activate a virtual environment"},{"location":"getting_started/tutorial/#install-wagtail-live-and-other-dependencies","text":"Use pip to install Wagtail and Wagtail Live: $ python -m pip install wagtail $ python -m pip install wagtail-live","title":"Install Wagtail Live and other dependencies"},{"location":"getting_started/tutorial/#generate-your-site","text":"Because the folder livesite was already created by venv , run wagtail start with an additional argument to specify the destination directory: $ wagtail start livesite livesite","title":"Generate your site"},{"location":"getting_started/tutorial/#create-your-first-live-page","text":"Start a new liveblog app: $ cd livesite $ python3 manage.py startapp liveblog You will then need to add wagtail_live and liveblog to your INSTALLED_APPS in your settings.base file: INSTALLED_APPS = [ 'home' , 'search' , 'liveblog' , 'wagtail_live' , ... # Other apps ] We can now create our first LiveBlogPage . Add the following in liveblog.models : from wagtail.core.models import Page from wagtail_live.models import LivePageMixin class LiveBlogPage ( Page , LivePageMixin ): content_panels = Page . content_panels + LivePageMixin . panels We'll need to specify the path to our live page model as the value of the WAGTAIL_LIVE_PAGE_MODEL setting: WAGTAIL_LIVE_PAGE_MODEL = \"liveblog.models.LiveBlogPage\" Create a templates folder inside your liveblog app. Add a liveblog folder in the templates folder that you just created and create a live_blog_page.html file. This represents our LiveBlogPage template. For now, add this to your live_blog_page.html template: { % include \"wagtail_live/live_posts.html\" % } That's all we need in our models.","title":"Create your first live page"},{"location":"getting_started/tutorial/#configuring-a-publisher","text":"The goal of publishers is to \"publish\" new updates to the frontend/client side. Choose and configure a publisher from the following list: Long Polling: Set up long polling publisher Interval Polling: Set up interval polling publisher Django channels: Set up Django channels publisher PieSocket: Set up PieSocket publisher Websockets: Set up websockets publisher Starlette: Set up starlette publisher","title":"Configuring a publisher"},{"location":"getting_started/tutorial/#configure-an-input-source-and-its-corresponding-receiver","text":"We need an input source for our live blog. An input source is a platform (often a messaging app, but any other tool that allows content editing and offers an API can be used) where we edit the content that appears on the front-end/client side. We also need a receiver for our input source. The goal of a receiver is to receive/retrieve updates from an input source. Choose an input source from the following list and configure its corresponding receiver: Slack: Setup Slack Events API receiver Telegram: Setup Telegram webhook receiver That's it for the configuration part.","title":"Configure an input source and its corresponding receiver"},{"location":"getting_started/tutorial/#create-the-database","text":"Finally, let's create our tables and an admin user: $ python3 manage.py makemigrations $ python3 manage.py migrate $ python3 manage.py createsuperuser When logged into the admin site, a superuser has full permissions and is able to view/create/manage the database.","title":"Create the database"},{"location":"getting_started/tutorial/#liveblogging","text":"Start the development server as following: $ python3 manage.py runserver Go to http://127.0.0.1:8000/admin/ and create a new page of type LiveBlogPage . You can choose the title you like for the page and fill the channel_id field with the ID of the channel you created in the input source chosen (Slack/Telegram). Click on the Live button to display the page. Enter the channel you created in the input source chosen and start posting. You should see your posts in the page momentarily!","title":"Liveblogging"},{"location":"getting_started/publishers/setup_django_channels/","text":"Set up Django Channels publisher This document describes how to set up a publisher using the websocket technique and Django channels. Set up channels Install channels First, follow the steps described here to install channels . Add Wagtail Live websocket route In your project's asgi.py , add Wagtail Live websocket route like this: # mysite/asgi.py import os from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter , URLRouter from django.core.asgi import get_asgi_application from wagtail_live.publishers.django_channels import live_websocket_route os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"wagtail_live_demo.settings.dev\" ) application = ProtocolTypeRouter ({ \"http\" : get_asgi_application (), \"websocket\" : AuthMiddlewareStack ( URLRouter ( live_websocket_route , ) ), }) Enable a channel layer The last step is to enable a channel layer. Follow the steps here to add a channel layer to your project. Configure WAGTAIL_LIVE_PUBLISHER In order to use Django channels for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.django_channels.DjangoChannelsPublisher\" Add publisher template We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/django_channels.html\" % }","title":"Set up Django channels publisher"},{"location":"getting_started/publishers/setup_django_channels/#set-up-django-channels-publisher","text":"This document describes how to set up a publisher using the websocket technique and Django channels.","title":"Set up Django Channels publisher"},{"location":"getting_started/publishers/setup_django_channels/#set-up-channels","text":"","title":"Set up channels"},{"location":"getting_started/publishers/setup_django_channels/#install-channels","text":"First, follow the steps described here to install channels .","title":"Install channels"},{"location":"getting_started/publishers/setup_django_channels/#add-wagtail-live-websocket-route","text":"In your project's asgi.py , add Wagtail Live websocket route like this: # mysite/asgi.py import os from channels.auth import AuthMiddlewareStack from channels.routing import ProtocolTypeRouter , URLRouter from django.core.asgi import get_asgi_application from wagtail_live.publishers.django_channels import live_websocket_route os . environ . setdefault ( \"DJANGO_SETTINGS_MODULE\" , \"wagtail_live_demo.settings.dev\" ) application = ProtocolTypeRouter ({ \"http\" : get_asgi_application (), \"websocket\" : AuthMiddlewareStack ( URLRouter ( live_websocket_route , ) ), })","title":"Add Wagtail Live websocket route"},{"location":"getting_started/publishers/setup_django_channels/#enable-a-channel-layer","text":"The last step is to enable a channel layer. Follow the steps here to add a channel layer to your project.","title":"Enable a channel layer"},{"location":"getting_started/publishers/setup_django_channels/#configure-wagtail_live_publisher","text":"In order to use Django channels for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.django_channels.DjangoChannelsPublisher\"","title":"Configure WAGTAIL_LIVE_PUBLISHER"},{"location":"getting_started/publishers/setup_django_channels/#add-publisher-template","text":"We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/django_channels.html\" % }","title":"Add publisher template"},{"location":"getting_started/publishers/setup_event_bus_redis/","text":"Set up redis based event bus This document describes how to set up an event bus with Redis, for Wagtail Live publishers. An event bus provides an abstraction over the Publish/Subscribe pattern . The goal of the event bus in Wagtail Live is the following: Publisher : A live page sends a new message containing its recent modifications to its channel group. Each live page is associated to a unique channel group. Subscriber : The users viewing a page in live subscribe to that page's channel group and receive the page modifications as soon as possible. Redis provides PubSub commands . We will then need to install redis and aioredis . The latter provides asyncio Redis support. Install redis Follow the steps outlined here to install Redis. Whenever you want to test your application, you will have to start the Redis server. If you have docker installed, you can run this command: docker run -p 6379:6379 -d redis:5 Install aioredis To install aioredis , type: $ pip install aioredis","title":"Set up an event bus based on Redis PubSub"},{"location":"getting_started/publishers/setup_event_bus_redis/#set-up-redis-based-event-bus","text":"This document describes how to set up an event bus with Redis, for Wagtail Live publishers. An event bus provides an abstraction over the Publish/Subscribe pattern . The goal of the event bus in Wagtail Live is the following: Publisher : A live page sends a new message containing its recent modifications to its channel group. Each live page is associated to a unique channel group. Subscriber : The users viewing a page in live subscribe to that page's channel group and receive the page modifications as soon as possible. Redis provides PubSub commands . We will then need to install redis and aioredis . The latter provides asyncio Redis support.","title":"Set up redis based event bus"},{"location":"getting_started/publishers/setup_event_bus_redis/#install-redis","text":"Follow the steps outlined here to install Redis. Whenever you want to test your application, you will have to start the Redis server. If you have docker installed, you can run this command: docker run -p 6379:6379 -d redis:5","title":"Install redis"},{"location":"getting_started/publishers/setup_event_bus_redis/#install-aioredis","text":"To install aioredis , type: $ pip install aioredis","title":"Install aioredis"},{"location":"getting_started/publishers/setup_interval_polling/","text":"Set up interval polling Publisher This document describes how to set up a publisher using the interval polling technique. Configure WAGTAIL_LIVE_PUBLISHER In order to use the interval polling technique for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.polling.IntervalPollingPublisher\" You can optionally set a polling interval: WAGTAIL_LIVE_POLLING_INTERVAL = value # in milliseconds The default value is 3000 (ms). Add publisher template We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/polling/interval_polling.html\" % } Make sure you have these 2 lines in your template: { % include \"wagtail_live/live_posts.html\" % } { % include \"wagtail_live/polling/interval_polling.html\" % } Add URLs Add the Wagtail Live URLs to your urls.py : from django.urls import include , path from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ]","title":"Set up interval polling publisher"},{"location":"getting_started/publishers/setup_interval_polling/#set-up-interval-polling-publisher","text":"This document describes how to set up a publisher using the interval polling technique.","title":"Set up interval polling Publisher"},{"location":"getting_started/publishers/setup_interval_polling/#configure-wagtail_live_publisher","text":"In order to use the interval polling technique for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.polling.IntervalPollingPublisher\" You can optionally set a polling interval: WAGTAIL_LIVE_POLLING_INTERVAL = value # in milliseconds The default value is 3000 (ms).","title":"Configure WAGTAIL_LIVE_PUBLISHER"},{"location":"getting_started/publishers/setup_interval_polling/#add-publisher-template","text":"We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/polling/interval_polling.html\" % } Make sure you have these 2 lines in your template: { % include \"wagtail_live/live_posts.html\" % } { % include \"wagtail_live/polling/interval_polling.html\" % }","title":"Add publisher template"},{"location":"getting_started/publishers/setup_interval_polling/#add-urls","text":"Add the Wagtail Live URLs to your urls.py : from django.urls import include , path from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ]","title":"Add URLs"},{"location":"getting_started/publishers/setup_long_polling/","text":"Set up long polling Publisher This document describes how to set up a publisher using the long polling technique. Configure WAGTAIL_LIVE_PUBLISHER In order to use the long polling technique for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.polling.LongPollingPublisher\" You can optionally set a polling timeout: WAGTAIL_LIVE_POLLING_TIMEOUT = value # in seconds The default value is 60 (s). Add publisher template We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/polling/long_polling.html\" % } Make sure you have these 2 lines in your template: { % include \"wagtail_live/live_posts.html\" % } { % include \"wagtail_live/polling/long_polling.html\" % } Add URLs Add the Wagtail Live URLs to your urls.py : from django.urls import include , path from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ]","title":"Set up long polling publisher"},{"location":"getting_started/publishers/setup_long_polling/#set-up-long-polling-publisher","text":"This document describes how to set up a publisher using the long polling technique.","title":"Set up long polling Publisher"},{"location":"getting_started/publishers/setup_long_polling/#configure-wagtail_live_publisher","text":"In order to use the long polling technique for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.polling.LongPollingPublisher\" You can optionally set a polling timeout: WAGTAIL_LIVE_POLLING_TIMEOUT = value # in seconds The default value is 60 (s).","title":"Configure WAGTAIL_LIVE_PUBLISHER"},{"location":"getting_started/publishers/setup_long_polling/#add-publisher-template","text":"We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/polling/long_polling.html\" % } Make sure you have these 2 lines in your template: { % include \"wagtail_live/live_posts.html\" % } { % include \"wagtail_live/polling/long_polling.html\" % }","title":"Add publisher template"},{"location":"getting_started/publishers/setup_long_polling/#add-urls","text":"Add the Wagtail Live URLs to your urls.py : from django.urls import include , path from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ]","title":"Add URLs"},{"location":"getting_started/publishers/setup_piesocket/","text":"Set up PieSocket publisher Note PieSocket offers a 'free-plus' plan to Wagtail-live users. This is the same as the free plan, but with an increased limit of 1 million messages per day. To benefit from this offer, follow the partner link instead of the regular one. This document describes how to set up a publisher using PieSocket ( partner link ) websocket server API. Create a PieSocket account First, you will need to create a PieSocket account here ( partner link ). Create a new API key Once you have created an account, you will need to create a new API KEY . In your dashboard, fill in the key name field and click the CREATE NEW KEY button. Retrieve your API key, your secret and PieSocket endpoint Wagtail Live needs your API_KEY and your SECRET . It also needs the API endpoint to use. After creating a new key, you can click the little information icon to find them as shown below: Add your credentials and PieSocket endpoint to settings The PieSocket endpoint depends on the cluster. In the above image the PieSocket endpoint is: us-nyc-1.piesocket.com/v3/ . Add the following in your settings.base file: PIESOCKET_API_KEY = \"your-api-key\" PIESOCKET_SECRET = \"your-secret\" PIESOCKET_ENDPOINT = \"your-piesocket-endpoint\" Configure WAGTAIL_LIVE_PUBLISHER In order to use PieSocket for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.piesocket.PieSocketPublisher\" Add publisher template We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/piesocket.html\" % }","title":"Set up PieSocket publisher"},{"location":"getting_started/publishers/setup_piesocket/#set-up-piesocket-publisher","text":"Note PieSocket offers a 'free-plus' plan to Wagtail-live users. This is the same as the free plan, but with an increased limit of 1 million messages per day. To benefit from this offer, follow the partner link instead of the regular one. This document describes how to set up a publisher using PieSocket ( partner link ) websocket server API.","title":"Set up PieSocket publisher"},{"location":"getting_started/publishers/setup_piesocket/#create-a-piesocket-account","text":"First, you will need to create a PieSocket account here ( partner link ).","title":"Create a PieSocket account"},{"location":"getting_started/publishers/setup_piesocket/#create-a-new-api-key","text":"Once you have created an account, you will need to create a new API KEY . In your dashboard, fill in the key name field and click the CREATE NEW KEY button.","title":"Create a new API key"},{"location":"getting_started/publishers/setup_piesocket/#retrieve-your-api-key-your-secret-and-piesocket-endpoint","text":"Wagtail Live needs your API_KEY and your SECRET . It also needs the API endpoint to use. After creating a new key, you can click the little information icon to find them as shown below:","title":"Retrieve your API key, your secret and PieSocket endpoint"},{"location":"getting_started/publishers/setup_piesocket/#add-your-credentials-and-piesocket-endpoint-to-settings","text":"The PieSocket endpoint depends on the cluster. In the above image the PieSocket endpoint is: us-nyc-1.piesocket.com/v3/ . Add the following in your settings.base file: PIESOCKET_API_KEY = \"your-api-key\" PIESOCKET_SECRET = \"your-secret\" PIESOCKET_ENDPOINT = \"your-piesocket-endpoint\"","title":"Add your credentials and PieSocket endpoint to settings"},{"location":"getting_started/publishers/setup_piesocket/#configure-wagtail_live_publisher","text":"In order to use PieSocket for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.piesocket.PieSocketPublisher\"","title":"Configure WAGTAIL_LIVE_PUBLISHER"},{"location":"getting_started/publishers/setup_piesocket/#add-publisher-template","text":"We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/piesocket.html\" % }","title":"Add publisher template"},{"location":"getting_started/publishers/setup_starlette/","text":"Set up Starlette publisher This document describes how to set up a publisher using the websocket technique and Starlette . Starlette is a lightweight ASGI framework. Set up event bus First, follow the steps in set up an event bus . Install starlette Install starlette : $ pip install starlette Configure WAGTAIL_LIVE_PUBLISHER In order to use starlette for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.starlette.StarlettePublisher\" Configure server host and port In this architecture, you will need a separate server to handle websocket connections. You can define the server's host and port in your settings file as follows: WAGTAIL_LIVE_SERVER_HOST = \"my-server-host\" # Defaults to `localhost`. WAGTAIL_LIVE_SERVER_PORT = \"my-server-port\" # Defaults to `8765`. In development mode, you can use the following command to start the server: python manage.py run_publisher starlette Add publisher template We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/starlette.html\" % }","title":"Set up starlette publisher"},{"location":"getting_started/publishers/setup_starlette/#set-up-starlette-publisher","text":"This document describes how to set up a publisher using the websocket technique and Starlette . Starlette is a lightweight ASGI framework.","title":"Set up Starlette publisher"},{"location":"getting_started/publishers/setup_starlette/#set-up-event-bus","text":"First, follow the steps in set up an event bus .","title":"Set up event bus"},{"location":"getting_started/publishers/setup_starlette/#install-starlette","text":"Install starlette : $ pip install starlette","title":"Install starlette"},{"location":"getting_started/publishers/setup_starlette/#configure-wagtail_live_publisher","text":"In order to use starlette for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.starlette.StarlettePublisher\"","title":"Configure WAGTAIL_LIVE_PUBLISHER"},{"location":"getting_started/publishers/setup_starlette/#configure-server-host-and-port","text":"In this architecture, you will need a separate server to handle websocket connections. You can define the server's host and port in your settings file as follows: WAGTAIL_LIVE_SERVER_HOST = \"my-server-host\" # Defaults to `localhost`. WAGTAIL_LIVE_SERVER_PORT = \"my-server-port\" # Defaults to `8765`. In development mode, you can use the following command to start the server: python manage.py run_publisher starlette","title":"Configure server host and port"},{"location":"getting_started/publishers/setup_starlette/#add-publisher-template","text":"We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/starlette.html\" % }","title":"Add publisher template"},{"location":"getting_started/publishers/setup_websockets/","text":"Set up Websockets publisher This document describes how to set up a publisher using the websocket technique and Websockets . Websockets is an efficient library for building WebSocket servers and clients in Python. Set up event bus First, follow the steps in set up an event bus . Install websockets Install websockets : $ pip install websockets Configure WAGTAIL_LIVE_PUBLISHER In order to use websockets for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.websockets.WebsocketsPublisher\" Configure server host and port In this architecture, you will need a separate server to handle websocket connections. You can define the server's host and port in your settings file by doing so: WAGTAIL_LIVE_SERVER_HOST = \"my-server-host\" # Defaults to `localhost`. WAGTAIL_LIVE_SERVER_PORT = \"my-server-port\" # Defaults to `8765`. In development mode, you can use the following command to start the server: python manage.py run_publisher websockets Add publisher template We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/websockets.html\" % }","title":"Set up websockets publisher"},{"location":"getting_started/publishers/setup_websockets/#set-up-websockets-publisher","text":"This document describes how to set up a publisher using the websocket technique and Websockets . Websockets is an efficient library for building WebSocket servers and clients in Python.","title":"Set up Websockets publisher"},{"location":"getting_started/publishers/setup_websockets/#set-up-event-bus","text":"First, follow the steps in set up an event bus .","title":"Set up event bus"},{"location":"getting_started/publishers/setup_websockets/#install-websockets","text":"Install websockets : $ pip install websockets","title":"Install websockets"},{"location":"getting_started/publishers/setup_websockets/#configure-wagtail_live_publisher","text":"In order to use websockets for the publishing part, add this to your settings : WAGTAIL_LIVE_PUBLISHER = \"wagtail_live.publishers.websockets.WebsocketsPublisher\"","title":"Configure WAGTAIL_LIVE_PUBLISHER"},{"location":"getting_started/publishers/setup_websockets/#configure-server-host-and-port","text":"In this architecture, you will need a separate server to handle websocket connections. You can define the server's host and port in your settings file by doing so: WAGTAIL_LIVE_SERVER_HOST = \"my-server-host\" # Defaults to `localhost`. WAGTAIL_LIVE_SERVER_PORT = \"my-server-port\" # Defaults to `8765`. In development mode, you can use the following command to start the server: python manage.py run_publisher websockets","title":"Configure server host and port"},{"location":"getting_started/publishers/setup_websockets/#add-publisher-template","text":"We also need to add this to our live_blog_page.html template: { % include \"wagtail_live/websocket/websockets.html\" % }","title":"Add publisher template"},{"location":"getting_started/receivers/setup_ngrok/","text":"Set up a local web server with ngrok When using Wagtail Live, especially webhook receivers, you will often need to register a public URL which messaging apps use to send new updates to your Wagtail site. In a development environment, ngrok can help us expose a public web server and tunnel requests to our local server. Downloading ngrok Head to ngrok and download the version that corresponds to your platform. Installing ngrok To install ngrok, we only need to extract the file into a folder. Extract the ngrok zip file into the folder of your preference. - in downloads/ngrok_folder for example - Start ngrok server Navigate to the directory where you extracted ngrok - in our example downloads/ngrok_folder - and then start the server as follows: $ cd downloads/ngrok_folder $ ./ngrok http 8000 If all goes well, you should see something like this: ngrok by @inconshreveable (Ctrl+C to quit) Session Status online Update update available (version 2.3.40, Ctrl-U to update Version 2.35 Web Interface http://127.0.1:4040 Forwarding http://4e0cd6d40780.ngrok.io -> http:localhost:8000 Forwarding https://4e0cd6d40780.ngrok.io -> http:localhost:8000 Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 Note Most messaging apps will require the one that starts with https:// . You can now register a public-facing URL that tunnels to your local server.","title":"Set up a local web server with ngrok"},{"location":"getting_started/receivers/setup_ngrok/#set-up-a-local-web-server-with-ngrok","text":"When using Wagtail Live, especially webhook receivers, you will often need to register a public URL which messaging apps use to send new updates to your Wagtail site. In a development environment, ngrok can help us expose a public web server and tunnel requests to our local server.","title":"Set up a local web server with ngrok"},{"location":"getting_started/receivers/setup_ngrok/#downloading-ngrok","text":"Head to ngrok and download the version that corresponds to your platform.","title":"Downloading ngrok"},{"location":"getting_started/receivers/setup_ngrok/#installing-ngrok","text":"To install ngrok, we only need to extract the file into a folder. Extract the ngrok zip file into the folder of your preference. - in downloads/ngrok_folder for example -","title":"Installing ngrok"},{"location":"getting_started/receivers/setup_ngrok/#start-ngrok-server","text":"Navigate to the directory where you extracted ngrok - in our example downloads/ngrok_folder - and then start the server as follows: $ cd downloads/ngrok_folder $ ./ngrok http 8000 If all goes well, you should see something like this: ngrok by @inconshreveable (Ctrl+C to quit) Session Status online Update update available (version 2.3.40, Ctrl-U to update Version 2.35 Web Interface http://127.0.1:4040 Forwarding http://4e0cd6d40780.ngrok.io -> http:localhost:8000 Forwarding https://4e0cd6d40780.ngrok.io -> http:localhost:8000 Connections ttl opn rt1 rt5 p50 p90 0 0 0.00 0.00 0.00 0.00 Note Most messaging apps will require the one that starts with https:// . You can now register a public-facing URL that tunnels to your local server.","title":"Start ngrok server"},{"location":"getting_started/receivers/setup_slack/","text":"Set up Slack Events API receiver This document walks you through how to set up Slack as an input source for your live blog and use their Events API to receive new updates. Create a Slack app First, you will need to create a Slack app . You may be prompted to create it from scratch or from an App Manifest. For the purpose of this tutorial, you can create your app from scratch. Fill out your app name and pick a workspace to develop your app in. Click the Create App button and you should see your app's Basic Information page. Retrieve your tokens Wagtail Live needs the following information to communicate with your app: SLACK_SIGNING_SECRET Slack signs all the requests it sends using a secret key. Wagtail Live needs that key to confirm that requests sent to the wagtail_live/slack/events endpoint come from Slack, by verifying their unique signature (you will learn more about this endpoint later). To find your secret key, go back to your app's page and navigate to the Basic Information section on the left sidebar. Scroll down to App Credentials and you'll find your Signing Secret in the SLACK_SIGNING_SECRET field. Grab it and keep it in a safe place. SLACK_BOT_TOKEN You will need to provide this token to be able to download images from the Slack API. In your app's Basic Information page, navigate to the OAuth & Permissions on the left sidebar and scroll down to the Bot Token Scopes section. Click Add an OAuth Scope . Add the channels:history scope. This scope lets your app view messages and other content in public channels that your Slack app has been added to. Add the files:read scope. This scope gives your app the ability to read/download images in channels and conversations your Slack app has been added to Scroll up to the top of the OAuth & Permissions page and click Install App to Workspace . You\u2019ll need to allow your app to be installed to your development workspace. Once you authorize the installation, you\u2019ll get back to the OAuth & Permissions page and see a Bot User OAuth Access Token which starts with xoxb- . Grab the token and copy it somewhere. Keep your token safe! Add your tokens to settings Add the following in your settings.base file: SLACK_SIGNING_SECRET = \"your-signing-secret\" SLACK_BOT_TOKEN = \"your-bot-token\" Receiving Slack events In order to receive events like when a message is sent in a channel, you need to hook a Request URL that Slack uses to send HTTP POST requests corresponding to events you specify. This URL needs to be publicly accessible. In the development phase, you will need a development proxy that creates a public URL and tunnels requests to your local server when you run python3 manage.py runserver in order to receive events from Slack. If you are comfortable with ngrok, start ngrok on port 8000. Otherwise you can see how to Set up a local web server with ngrok . Configure SlackEventsAPIReceiver Add the following to your urls.py file if not done yet: from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ] Add the following to your settings file: WAGTAIL_LIVE_RECEIVER = \"wagtail_live.receivers.slack.SlackEventsAPIReceiver\" Make sure ngrok is running on port 8000 and start the development server in another shell like this: $ python3 manage.py runserver Hook your request URL Go back to your app's Basic Information page and look for Event Subscriptions . Toggle the Enable events button. You'll be asked to type a Request URL . Get the URL generated by ngrok (the one that starts with https://) and append /wagtail_live/slack/events to it. For example, if your generated URL is something like https://abc.ngrok.io , then the Request URL you should enter in Slack should be https://abc.ngrok.io/wagtail_live/slack/events . As soon as you type the URL, Slack will send a POST request to verify it. Wagtail Live should handle this verification for you. You should see a green box indicating that your Request URL has been verified. From now on, Slack will send a POST request to https://abc.ngrok.io/wagtail_live/slack/events whenever an event your bot has subscribed to occurs in Slack. Channel configuration Subscribe to Bot Events After your request URL is verified, scroll down to Subscribe to Bot Events and click the Add Bot User Event button. Choose the message.channels event and hit the Save Changes button. This allows your bot to listen for messages in public channels that it is added to. To listen for other types of messages/channels, see this list to check which scope you need to grant to your bot. Add your app to a channel In the workspace where you installed the app, create a new channel. In the channel's page, look for the Show channel details icon at the top right of the page and click it. You will see another More dropdown button, click it and choose Add apps . Add your app to the channel. Retrieve your channel's ID To finish, you will need your channel's ID to create a page which will map to this channel in your live site. To find the identifier of the channel you created, go to the channel's page, and grab the second identifier in the URL displayed on the address bar. For example, if you go on your channel's page and the URL looks like https://app.slack.com/client/T023G8L63FS/C024931MDK3 , then your channel identifier is C024931MDK3 . You can then create a live page and add this identifier to the channel_id field of that page. From then, all messages changed/edited/deleted in the channel you created in Slack will be synced with your live page!","title":"Set up Slack Events API receiver"},{"location":"getting_started/receivers/setup_slack/#set-up-slack-events-api-receiver","text":"This document walks you through how to set up Slack as an input source for your live blog and use their Events API to receive new updates.","title":"Set up Slack Events API receiver"},{"location":"getting_started/receivers/setup_slack/#create-a-slack-app","text":"First, you will need to create a Slack app . You may be prompted to create it from scratch or from an App Manifest. For the purpose of this tutorial, you can create your app from scratch. Fill out your app name and pick a workspace to develop your app in. Click the Create App button and you should see your app's Basic Information page.","title":"Create a Slack app"},{"location":"getting_started/receivers/setup_slack/#retrieve-your-tokens","text":"Wagtail Live needs the following information to communicate with your app: SLACK_SIGNING_SECRET Slack signs all the requests it sends using a secret key. Wagtail Live needs that key to confirm that requests sent to the wagtail_live/slack/events endpoint come from Slack, by verifying their unique signature (you will learn more about this endpoint later). To find your secret key, go back to your app's page and navigate to the Basic Information section on the left sidebar. Scroll down to App Credentials and you'll find your Signing Secret in the SLACK_SIGNING_SECRET field. Grab it and keep it in a safe place. SLACK_BOT_TOKEN You will need to provide this token to be able to download images from the Slack API. In your app's Basic Information page, navigate to the OAuth & Permissions on the left sidebar and scroll down to the Bot Token Scopes section. Click Add an OAuth Scope . Add the channels:history scope. This scope lets your app view messages and other content in public channels that your Slack app has been added to. Add the files:read scope. This scope gives your app the ability to read/download images in channels and conversations your Slack app has been added to Scroll up to the top of the OAuth & Permissions page and click Install App to Workspace . You\u2019ll need to allow your app to be installed to your development workspace. Once you authorize the installation, you\u2019ll get back to the OAuth & Permissions page and see a Bot User OAuth Access Token which starts with xoxb- . Grab the token and copy it somewhere. Keep your token safe!","title":"Retrieve your tokens"},{"location":"getting_started/receivers/setup_slack/#add-your-tokens-to-settings","text":"Add the following in your settings.base file: SLACK_SIGNING_SECRET = \"your-signing-secret\" SLACK_BOT_TOKEN = \"your-bot-token\"","title":"Add your tokens to settings"},{"location":"getting_started/receivers/setup_slack/#receiving-slack-events","text":"In order to receive events like when a message is sent in a channel, you need to hook a Request URL that Slack uses to send HTTP POST requests corresponding to events you specify. This URL needs to be publicly accessible. In the development phase, you will need a development proxy that creates a public URL and tunnels requests to your local server when you run python3 manage.py runserver in order to receive events from Slack. If you are comfortable with ngrok, start ngrok on port 8000. Otherwise you can see how to Set up a local web server with ngrok .","title":"Receiving Slack events"},{"location":"getting_started/receivers/setup_slack/#configure-slackeventsapireceiver","text":"Add the following to your urls.py file if not done yet: from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ] Add the following to your settings file: WAGTAIL_LIVE_RECEIVER = \"wagtail_live.receivers.slack.SlackEventsAPIReceiver\" Make sure ngrok is running on port 8000 and start the development server in another shell like this: $ python3 manage.py runserver","title":"Configure SlackEventsAPIReceiver"},{"location":"getting_started/receivers/setup_slack/#hook-your-request-url","text":"Go back to your app's Basic Information page and look for Event Subscriptions . Toggle the Enable events button. You'll be asked to type a Request URL . Get the URL generated by ngrok (the one that starts with https://) and append /wagtail_live/slack/events to it. For example, if your generated URL is something like https://abc.ngrok.io , then the Request URL you should enter in Slack should be https://abc.ngrok.io/wagtail_live/slack/events . As soon as you type the URL, Slack will send a POST request to verify it. Wagtail Live should handle this verification for you. You should see a green box indicating that your Request URL has been verified. From now on, Slack will send a POST request to https://abc.ngrok.io/wagtail_live/slack/events whenever an event your bot has subscribed to occurs in Slack.","title":"Hook your request URL"},{"location":"getting_started/receivers/setup_slack/#channel-configuration","text":"","title":"Channel configuration"},{"location":"getting_started/receivers/setup_slack/#subscribe-to-bot-events","text":"After your request URL is verified, scroll down to Subscribe to Bot Events and click the Add Bot User Event button. Choose the message.channels event and hit the Save Changes button. This allows your bot to listen for messages in public channels that it is added to. To listen for other types of messages/channels, see this list to check which scope you need to grant to your bot.","title":"Subscribe to Bot Events"},{"location":"getting_started/receivers/setup_slack/#add-your-app-to-a-channel","text":"In the workspace where you installed the app, create a new channel. In the channel's page, look for the Show channel details icon at the top right of the page and click it. You will see another More dropdown button, click it and choose Add apps . Add your app to the channel.","title":"Add your app to a channel"},{"location":"getting_started/receivers/setup_slack/#retrieve-your-channels-id","text":"To finish, you will need your channel's ID to create a page which will map to this channel in your live site. To find the identifier of the channel you created, go to the channel's page, and grab the second identifier in the URL displayed on the address bar. For example, if you go on your channel's page and the URL looks like https://app.slack.com/client/T023G8L63FS/C024931MDK3 , then your channel identifier is C024931MDK3 . You can then create a live page and add this identifier to the channel_id field of that page. From then, all messages changed/edited/deleted in the channel you created in Slack will be synced with your live page!","title":"Retrieve your channel's ID"},{"location":"getting_started/receivers/setup_telegram/","text":"Set up Telegram webhook receiver This document walks you through how to set up Telegram as an input source for your live blog and set a webhook connection to receive new updates. Create a Telegram bot First, you will need to create a Telegram bot . After creating a bot, an authorization token will be genrated for your new bot. The token is a string along the lines of 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw that is required to authorize the bot and send requests to the Bot API. Keep your token secure and store it safely, it can be used by anyone to control your bot. Add your bot token to settings Add the following in your settings.base file: TELEGRAM_BOT_TOKEN = \"your-bot-token\" Receiving Telegram events In order to receive events like when a message is sent in a channel, you need to hook a Webhook URL that Telegram uses to send HTTP POST requests corresponding to events you specify. This URL needs to be publicly accessible. Configure TELEGRAM_WEBHOOK_URL In the development phase, you will need a development proxy that creates a public URL and tunnels requests to your local server when you run python3 manage.py runserver in order to receive events from Telegram. If you are comfortable with ngrok, start ngrok on port 8000. Otherwise you can see how to Set up a local web server with ngrok . Make sure ngrok is running on port 8000 and add the URL generated by ngrok to your settings file: ```python TELEGRAM_WEBHOOK_URL = \"https://ngrok-generated-url.com\" ``` Configure TelegramWebhookReceiver Add the following in your urls.py file if not done yet: from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ] Add the following in your settings file: WAGTAIL_LIVE_RECEIVER = \"wagtail_live.receivers.telegram.TelegramWebhookReceiver\" That's all we need to receive events from Telegram. Run the following: $ python3 manage.py runserver If everything went well, the server should start without errors. Channel configuration We can send messages from the bot's channel or invite the bot in another channel. For this tutorial, we will post to the bot's channel directly. You can find the link to your bot's channel in BotFather where you created the bot. Retrieve chat ID In the chat where you want to post messages, type the following: /get_chat_id . Your bot will answer with the ID of the current chat. You can then create a live page and add the chat ID to the channel_id field of that page. From then, all messages added or edited in the chat will be synced with your live page! Note Telegram doesn't send updates when a message is deleted. This means that when you delete a message in a Telegram chat it won't be automatically deleted from your LivePage.","title":"Set up Telegram webhook receiver"},{"location":"getting_started/receivers/setup_telegram/#set-up-telegram-webhook-receiver","text":"This document walks you through how to set up Telegram as an input source for your live blog and set a webhook connection to receive new updates.","title":"Set up Telegram webhook receiver"},{"location":"getting_started/receivers/setup_telegram/#create-a-telegram-bot","text":"First, you will need to create a Telegram bot . After creating a bot, an authorization token will be genrated for your new bot. The token is a string along the lines of 110201543:AAHdqTcvCH1vGWJxfSeofSAs0K5PALDsaw that is required to authorize the bot and send requests to the Bot API. Keep your token secure and store it safely, it can be used by anyone to control your bot.","title":"Create a Telegram bot"},{"location":"getting_started/receivers/setup_telegram/#add-your-bot-token-to-settings","text":"Add the following in your settings.base file: TELEGRAM_BOT_TOKEN = \"your-bot-token\"","title":"Add your bot token to settings"},{"location":"getting_started/receivers/setup_telegram/#receiving-telegram-events","text":"In order to receive events like when a message is sent in a channel, you need to hook a Webhook URL that Telegram uses to send HTTP POST requests corresponding to events you specify. This URL needs to be publicly accessible.","title":"Receiving Telegram events"},{"location":"getting_started/receivers/setup_telegram/#configure-telegram_webhook_url","text":"In the development phase, you will need a development proxy that creates a public URL and tunnels requests to your local server when you run python3 manage.py runserver in order to receive events from Telegram. If you are comfortable with ngrok, start ngrok on port 8000. Otherwise you can see how to Set up a local web server with ngrok . Make sure ngrok is running on port 8000 and add the URL generated by ngrok to your settings file: ```python TELEGRAM_WEBHOOK_URL = \"https://ngrok-generated-url.com\" ```","title":"Configure TELEGRAM_WEBHOOK_URL"},{"location":"getting_started/receivers/setup_telegram/#configure-telegramwebhookreceiver","text":"Add the following in your urls.py file if not done yet: from wagtail_live import urls as live_urls urlpatterns += [ path ( 'wagtail_live/' , include ( live_urls )), ] Add the following in your settings file: WAGTAIL_LIVE_RECEIVER = \"wagtail_live.receivers.telegram.TelegramWebhookReceiver\" That's all we need to receive events from Telegram. Run the following: $ python3 manage.py runserver If everything went well, the server should start without errors.","title":"Configure TelegramWebhookReceiver"},{"location":"getting_started/receivers/setup_telegram/#channel-configuration","text":"We can send messages from the bot's channel or invite the bot in another channel. For this tutorial, we will post to the bot's channel directly. You can find the link to your bot's channel in BotFather where you created the bot.","title":"Channel configuration"},{"location":"getting_started/receivers/setup_telegram/#retrieve-chat-id","text":"In the chat where you want to post messages, type the following: /get_chat_id . Your bot will answer with the ID of the current chat. You can then create a live page and add the chat ID to the channel_id field of that page. From then, all messages added or edited in the chat will be synced with your live page! Note Telegram doesn't send updates when a message is deleted. This means that when you delete a message in a Telegram chat it won't be automatically deleted from your LivePage.","title":"Retrieve chat ID"},{"location":"reference/live-page-mixin/","text":"Live Page Mixin wagtail_live.models.LivePageMixin Base class for pages using Wagtail Live. Attributes: Name Type Description channel_id str Id of the corresponding channel in a messaging app. last_updated_at DateTime Date and time of the last update of this page. live_posts StreamField StreamField containing all the posts/messages published respectively on this page/channel. last_update_timestamp property readonly Timestamp of the last update of this page. add_live_post ( self , live_post ) Adds a new live post to live page. Parameters: Name Type Description Default live_post LivePostBlock live post to add required Source code in wagtail_live/models.py def add_live_post ( self , live_post ): \"\"\" Adds a new live post to live page. Args: live_post (LivePostBlock): live post to add \"\"\" posts = self . live_posts lp_index = 0 post_created_at = live_post [ \"created\" ] while lp_index < len ( posts ): if posts [ lp_index ] . value [ \"created\" ] < post_created_at : break lp_index += 1 # Insert to keep posts sorted by time self . live_posts . insert ( lp_index , ( \"live_post\" , live_post )) self . last_updated_at = post_created_at self . save ( sync = False ) live_post = self . get_live_post_by_index ( lp_index ) live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = [ live_post ], removals = [], ) delete_live_post ( self , message_id ) Deletes the live post corresponding to message_id. Parameters: Name Type Description Default message_id str ID of the message corresponding to a live post. required Exceptions: Type Description KeyError if live post containing message with message_id doesn't exist. Source code in wagtail_live/models.py def delete_live_post ( self , message_id ): \"\"\" Deletes the live post corresponding to message_id. Args: message_id (str): ID of the message corresponding to a live post. Raises: KeyError: if live post containing message with message_id doesn't exist. \"\"\" live_post_index = self . get_live_post_index ( message_id = message_id ) if live_post_index is None : raise KeyError live_post_id = self . live_posts [ live_post_index ] . id del self . live_posts [ live_post_index ] self . last_updated_at = timezone . now () self . save ( sync = False ) live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = {}, removals = [ live_post_id ], ) get_live_post_by_index ( self , live_post_index ) Retrieves a live post by its index. Parameters: Name Type Description Default live_post_index int Index of the live post to look for. required Returns: Type Description LivePostBlock The live post instance Exceptions: Type Description IndexError if a live post with the given index doesn't exist. Source code in wagtail_live/models.py def get_live_post_by_index ( self , live_post_index ): \"\"\" Retrieves a live post by its index. Args: live_post_index (int): Index of the live post to look for. Returns: LivePostBlock: The live post instance Raises: IndexError: if a live post with the given index doesn't exist. \"\"\" return self . live_posts [ live_post_index ] get_live_post_by_message_id ( self , message_id ) Retrieves a live post by its ID. Parameters: Name Type Description Default message_id str ID of the message corresponding to a live post. required Returns: Type Description LivePostBlock The live post instance Exceptions: Type Description KeyError if a live post with the given ID doesn't exist. Source code in wagtail_live/models.py def get_live_post_by_message_id ( self , message_id ): \"\"\" Retrieves a live post by its ID. Args: message_id (str): ID of the message corresponding to a live post. Returns: LivePostBlock: The live post instance Raises: KeyError: if a live post with the given ID doesn't exist. \"\"\" live_post_index = self . get_live_post_index ( message_id = message_id ) if live_post_index is None : raise KeyError return self . get_live_post_by_index ( live_post_index ) get_live_post_index ( self , message_id ) Retrieves the index of a live post. Parameters: Name Type Description Default message_id str ID of the message corresponding to a live post. required Returns: Type Description int Index of the live post if found else -1 Source code in wagtail_live/models.py def get_live_post_index ( self , message_id ): \"\"\" Retrieves the index of a live post. Args: message_id (str): ID of the message corresponding to a live post. Returns: int: Index of the live post if found else -1 \"\"\" return self . _get_live_post_index ( message_id = message_id ) get_updates_since ( self , last_update_ts ) Retrieves new updates since a given timestamp value. Parameters: Name Type Description Default last_update_ts DateTime Timestamp of the last update. required Returns: Type Description (list, dict) a tuple containing the current live posts and the updated posts since last_update_ts . Source code in wagtail_live/models.py def get_updates_since ( self , last_update_ts ): \"\"\" Retrieves new updates since a given timestamp value. Args: last_update_ts (DateTime): Timestamp of the last update. Returns: (list, dict): a tuple containing the current live posts and the updated posts since `last_update_ts`. \"\"\" # Reverse posts list so that latest updates are processed later by the client side. posts = reversed ( self . live_posts ) current_posts , updated_posts = [], {} for post in posts : post_id = post . id current_posts . append ( post_id ) created = post . value [ \"created\" ] if created >= last_update_ts : # This is a new post updated_posts [ post_id ] = { \"show\" : post . value [ \"show\" ], \"content\" : post . render ( context = { \"block_id\" : post . id }), } continue last_modified = post . value [ \"modified\" ] if last_modified and last_modified >= last_update_ts : # This is an edited post updated_posts [ post_id ] = { \"show\" : post . value [ \"show\" ], \"content\" : post . render ( context = { \"block_id\" : post . id }), } return ( updated_posts , current_posts ) save ( self , sync = True , * args , ** kwargs ) Update live page on save depending on the WAGTAIL_LIVE_SYNC_WITH_ADMIN setting. Source code in wagtail_live/models.py def save ( self , sync = True , * args , ** kwargs ): \"\"\"Update live page on save depending on the `WAGTAIL_LIVE_SYNC_WITH_ADMIN` setting.\"\"\" sync_changes = sync and getattr ( settings , \"WAGTAIL_LIVE_SYNC_WITH_ADMIN\" , True ) has_changed = False if sync_changes and self . id : renders , seen = [], set () previous_posts = { live_post . id : live_post for live_post in self . __class__ . objects . get ( id = self . id ) . live_posts } now = timezone . now () for i , post in enumerate ( self . live_posts ): # New posts post_id = post . id if post_id in previous_posts : seen . add ( post_id ) # Check if the post has been modified. previous_post = previous_posts [ post_id ] identic = compare_live_posts_values ( post . value , previous_post . value ) if not identic : post . value [ \"modified\" ] = now renders . append ( i ) else : # This is a new post. # Force the value of `created` here to keep it synchronized with the # `last_updated_at` property. # This is mostly to avoid missing new updates with the polling publishers. post . value [ \"created\" ] = now renders . append ( i ) removals = list ( set ( previous_posts . keys ()) . difference ( seen )) has_changed = bool ( renders or removals ) if has_changed : self . last_updated_at = now result = super () . save ( * args , ** kwargs ) if sync_changes and has_changed : # Reverse renders so the latest posts, which are in the start of the list, # are processed later in the front end. renders . reverse () renders = list ( map ( self . get_live_post_by_index , renders )) # Send signal. live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = renders , removals = removals , ) return result update_live_post ( self , live_post ) Updates a live post when it has been edited. Parameters: Name Type Description Default live_post livePostBlock Live post to update. required Source code in wagtail_live/models.py def update_live_post ( self , live_post ): \"\"\" Updates a live post when it has been edited. Args: live_post (livePostBlock): Live post to update. \"\"\" live_post . value [ \"modified\" ] = self . last_updated_at = timezone . now () self . save ( sync = False ) live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = [ live_post ], removals = [], )","title":"LivePageMixin"},{"location":"reference/live-page-mixin/#live-page-mixin","text":"","title":"Live Page Mixin"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin","text":"Base class for pages using Wagtail Live. Attributes: Name Type Description channel_id str Id of the corresponding channel in a messaging app. last_updated_at DateTime Date and time of the last update of this page. live_posts StreamField StreamField containing all the posts/messages published respectively on this page/channel.","title":"LivePageMixin"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.last_update_timestamp","text":"Timestamp of the last update of this page.","title":"last_update_timestamp"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.add_live_post","text":"Adds a new live post to live page. Parameters: Name Type Description Default live_post LivePostBlock live post to add required Source code in wagtail_live/models.py def add_live_post ( self , live_post ): \"\"\" Adds a new live post to live page. Args: live_post (LivePostBlock): live post to add \"\"\" posts = self . live_posts lp_index = 0 post_created_at = live_post [ \"created\" ] while lp_index < len ( posts ): if posts [ lp_index ] . value [ \"created\" ] < post_created_at : break lp_index += 1 # Insert to keep posts sorted by time self . live_posts . insert ( lp_index , ( \"live_post\" , live_post )) self . last_updated_at = post_created_at self . save ( sync = False ) live_post = self . get_live_post_by_index ( lp_index ) live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = [ live_post ], removals = [], )","title":"add_live_post()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.delete_live_post","text":"Deletes the live post corresponding to message_id. Parameters: Name Type Description Default message_id str ID of the message corresponding to a live post. required Exceptions: Type Description KeyError if live post containing message with message_id doesn't exist. Source code in wagtail_live/models.py def delete_live_post ( self , message_id ): \"\"\" Deletes the live post corresponding to message_id. Args: message_id (str): ID of the message corresponding to a live post. Raises: KeyError: if live post containing message with message_id doesn't exist. \"\"\" live_post_index = self . get_live_post_index ( message_id = message_id ) if live_post_index is None : raise KeyError live_post_id = self . live_posts [ live_post_index ] . id del self . live_posts [ live_post_index ] self . last_updated_at = timezone . now () self . save ( sync = False ) live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = {}, removals = [ live_post_id ], )","title":"delete_live_post()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.get_live_post_by_index","text":"Retrieves a live post by its index. Parameters: Name Type Description Default live_post_index int Index of the live post to look for. required Returns: Type Description LivePostBlock The live post instance Exceptions: Type Description IndexError if a live post with the given index doesn't exist. Source code in wagtail_live/models.py def get_live_post_by_index ( self , live_post_index ): \"\"\" Retrieves a live post by its index. Args: live_post_index (int): Index of the live post to look for. Returns: LivePostBlock: The live post instance Raises: IndexError: if a live post with the given index doesn't exist. \"\"\" return self . live_posts [ live_post_index ]","title":"get_live_post_by_index()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.get_live_post_by_message_id","text":"Retrieves a live post by its ID. Parameters: Name Type Description Default message_id str ID of the message corresponding to a live post. required Returns: Type Description LivePostBlock The live post instance Exceptions: Type Description KeyError if a live post with the given ID doesn't exist. Source code in wagtail_live/models.py def get_live_post_by_message_id ( self , message_id ): \"\"\" Retrieves a live post by its ID. Args: message_id (str): ID of the message corresponding to a live post. Returns: LivePostBlock: The live post instance Raises: KeyError: if a live post with the given ID doesn't exist. \"\"\" live_post_index = self . get_live_post_index ( message_id = message_id ) if live_post_index is None : raise KeyError return self . get_live_post_by_index ( live_post_index )","title":"get_live_post_by_message_id()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.get_live_post_index","text":"Retrieves the index of a live post. Parameters: Name Type Description Default message_id str ID of the message corresponding to a live post. required Returns: Type Description int Index of the live post if found else -1 Source code in wagtail_live/models.py def get_live_post_index ( self , message_id ): \"\"\" Retrieves the index of a live post. Args: message_id (str): ID of the message corresponding to a live post. Returns: int: Index of the live post if found else -1 \"\"\" return self . _get_live_post_index ( message_id = message_id )","title":"get_live_post_index()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.get_updates_since","text":"Retrieves new updates since a given timestamp value. Parameters: Name Type Description Default last_update_ts DateTime Timestamp of the last update. required Returns: Type Description (list, dict) a tuple containing the current live posts and the updated posts since last_update_ts . Source code in wagtail_live/models.py def get_updates_since ( self , last_update_ts ): \"\"\" Retrieves new updates since a given timestamp value. Args: last_update_ts (DateTime): Timestamp of the last update. Returns: (list, dict): a tuple containing the current live posts and the updated posts since `last_update_ts`. \"\"\" # Reverse posts list so that latest updates are processed later by the client side. posts = reversed ( self . live_posts ) current_posts , updated_posts = [], {} for post in posts : post_id = post . id current_posts . append ( post_id ) created = post . value [ \"created\" ] if created >= last_update_ts : # This is a new post updated_posts [ post_id ] = { \"show\" : post . value [ \"show\" ], \"content\" : post . render ( context = { \"block_id\" : post . id }), } continue last_modified = post . value [ \"modified\" ] if last_modified and last_modified >= last_update_ts : # This is an edited post updated_posts [ post_id ] = { \"show\" : post . value [ \"show\" ], \"content\" : post . render ( context = { \"block_id\" : post . id }), } return ( updated_posts , current_posts )","title":"get_updates_since()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.save","text":"Update live page on save depending on the WAGTAIL_LIVE_SYNC_WITH_ADMIN setting. Source code in wagtail_live/models.py def save ( self , sync = True , * args , ** kwargs ): \"\"\"Update live page on save depending on the `WAGTAIL_LIVE_SYNC_WITH_ADMIN` setting.\"\"\" sync_changes = sync and getattr ( settings , \"WAGTAIL_LIVE_SYNC_WITH_ADMIN\" , True ) has_changed = False if sync_changes and self . id : renders , seen = [], set () previous_posts = { live_post . id : live_post for live_post in self . __class__ . objects . get ( id = self . id ) . live_posts } now = timezone . now () for i , post in enumerate ( self . live_posts ): # New posts post_id = post . id if post_id in previous_posts : seen . add ( post_id ) # Check if the post has been modified. previous_post = previous_posts [ post_id ] identic = compare_live_posts_values ( post . value , previous_post . value ) if not identic : post . value [ \"modified\" ] = now renders . append ( i ) else : # This is a new post. # Force the value of `created` here to keep it synchronized with the # `last_updated_at` property. # This is mostly to avoid missing new updates with the polling publishers. post . value [ \"created\" ] = now renders . append ( i ) removals = list ( set ( previous_posts . keys ()) . difference ( seen )) has_changed = bool ( renders or removals ) if has_changed : self . last_updated_at = now result = super () . save ( * args , ** kwargs ) if sync_changes and has_changed : # Reverse renders so the latest posts, which are in the start of the list, # are processed later in the front end. renders . reverse () renders = list ( map ( self . get_live_post_by_index , renders )) # Send signal. live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = renders , removals = removals , ) return result","title":"save()"},{"location":"reference/live-page-mixin/#wagtail_live.models.LivePageMixin.update_live_post","text":"Updates a live post when it has been edited. Parameters: Name Type Description Default live_post livePostBlock Live post to update. required Source code in wagtail_live/models.py def update_live_post ( self , live_post ): \"\"\" Updates a live post when it has been edited. Args: live_post (livePostBlock): Live post to update. \"\"\" live_post . value [ \"modified\" ] = self . last_updated_at = timezone . now () self . save ( sync = False ) live_page_update . send ( sender = self . __class__ , channel_id = self . channel_id , renders = [ live_post ], removals = [], )","title":"update_live_post()"},{"location":"reference/settings/","text":"Settings Wagtail Live makes use of the following settings, in addition to Django's and Wagtail's: Core WAGTAIL_LIVE_PAGE_MODEL Description Required Default Path to the page model to use. The page specified must inherit from LivePageMixin . Yes None Example: WAGTAIL_LIVE_PAGE_MODEL = \"liveblog.models.LiveBlogPage\" WAGTAIL_LIVE_RECEIVER Description Required Default Path to the receiver to use. The receiver specified must inherit from BaseMessageReceiver . Yes None See Configure an input source and its corresponding receiver . WAGTAIL_LIVE_PUBLISHER Description Required Default Path to the publisher to use. Yes None See Configuring a publisher . Slack receivers SLACK_SIGNING_SECRET Description Required Default Slack signing secret For Slack receivers None SLACK_BOT_TOKEN Description Required Default Slack bot token. This is used to download images from the Slack API. For Slack receivers None Telegram receivers TELEGRAM_BOT_TOKEN Description Required Default Telegram bot token For Telegram receivers None TELEGRAM_WEBHOOK_URL Description Required Default The URL used by Telegram to send updates to your app. It must be publicly accessible and served over https . For Telegram receivers None Polling publishers WAGTAIL_LIVE_POLLING_TIMEOUT Description Required Default Polling timeout (in seconds) for the LongPollingPublisher No 60(s) WAGTAIL_LIVE_POLLING_INTERVAL Description Required Default Polling interval (in milliseconds) for the IntervalPollingPublisher No 3000(ms) Websocket publishers WAGTAIL_LIVE_REDIS_URL Description Required Default Redis server URL No redis://127.0.0.1:6379/1 WAGTAIL_LIVE_SERVER_HOST Description Required Default Server host for websocket publishers based on starlette, websockets... No localhost WAGTAIL_LIVE_SERVER_PORT Description Required Default Server port for websocket publishers based on starlette, websockets... No 8765 WAGTAIL_LIVE_USE_SECURE_WS_CONNECTION Description Required Default Determines if a publisher should use a secure WebSocket connection. Set this to True if your site is deployed over https since browsers don't allow insecure WebSocket connections (ws) from secure websites (https). No False Synchronize live page with admin interface WAGTAIL_LIVE_SYNC_WITH_ADMIN Description Required Default This setting controls the synchronization of a live page when it's modified in the admin interface. No True When WAGTAIL_LIVE_SYNC_WITH_ADMIN is True (default), the admin interface can be used as a way to publish instantly to a live page. When it's False , changes made in the admin interface aren't automatically/live published. You can set the value of this setting to False if you don't intend to use the admin interface to publish/edit live posts. This will avoid making computations to track changes made in the admin interface.","title":"Settings"},{"location":"reference/settings/#settings","text":"Wagtail Live makes use of the following settings, in addition to Django's and Wagtail's:","title":"Settings"},{"location":"reference/settings/#core","text":"","title":"Core"},{"location":"reference/settings/#wagtail_live_page_model","text":"Description Required Default Path to the page model to use. The page specified must inherit from LivePageMixin . Yes None Example: WAGTAIL_LIVE_PAGE_MODEL = \"liveblog.models.LiveBlogPage\"","title":"WAGTAIL_LIVE_PAGE_MODEL"},{"location":"reference/settings/#wagtail_live_receiver","text":"Description Required Default Path to the receiver to use. The receiver specified must inherit from BaseMessageReceiver . Yes None See Configure an input source and its corresponding receiver .","title":"WAGTAIL_LIVE_RECEIVER"},{"location":"reference/settings/#wagtail_live_publisher","text":"Description Required Default Path to the publisher to use. Yes None See Configuring a publisher .","title":"WAGTAIL_LIVE_PUBLISHER"},{"location":"reference/settings/#slack-receivers","text":"","title":"Slack receivers"},{"location":"reference/settings/#slack_signing_secret","text":"Description Required Default Slack signing secret For Slack receivers None","title":"SLACK_SIGNING_SECRET"},{"location":"reference/settings/#slack_bot_token","text":"Description Required Default Slack bot token. This is used to download images from the Slack API. For Slack receivers None","title":"SLACK_BOT_TOKEN"},{"location":"reference/settings/#telegram-receivers","text":"","title":"Telegram receivers"},{"location":"reference/settings/#telegram_bot_token","text":"Description Required Default Telegram bot token For Telegram receivers None","title":"TELEGRAM_BOT_TOKEN"},{"location":"reference/settings/#telegram_webhook_url","text":"Description Required Default The URL used by Telegram to send updates to your app. It must be publicly accessible and served over https . For Telegram receivers None","title":"TELEGRAM_WEBHOOK_URL"},{"location":"reference/settings/#polling-publishers","text":"","title":"Polling publishers"},{"location":"reference/settings/#wagtail_live_polling_timeout","text":"Description Required Default Polling timeout (in seconds) for the LongPollingPublisher No 60(s)","title":"WAGTAIL_LIVE_POLLING_TIMEOUT"},{"location":"reference/settings/#wagtail_live_polling_interval","text":"Description Required Default Polling interval (in milliseconds) for the IntervalPollingPublisher No 3000(ms)","title":"WAGTAIL_LIVE_POLLING_INTERVAL"},{"location":"reference/settings/#websocket-publishers","text":"","title":"Websocket publishers"},{"location":"reference/settings/#wagtail_live_redis_url","text":"Description Required Default Redis server URL No redis://127.0.0.1:6379/1","title":"WAGTAIL_LIVE_REDIS_URL"},{"location":"reference/settings/#wagtail_live_server_host","text":"Description Required Default Server host for websocket publishers based on starlette, websockets... No localhost","title":"WAGTAIL_LIVE_SERVER_HOST"},{"location":"reference/settings/#wagtail_live_server_port","text":"Description Required Default Server port for websocket publishers based on starlette, websockets... No 8765","title":"WAGTAIL_LIVE_SERVER_PORT"},{"location":"reference/settings/#wagtail_live_use_secure_ws_connection","text":"Description Required Default Determines if a publisher should use a secure WebSocket connection. Set this to True if your site is deployed over https since browsers don't allow insecure WebSocket connections (ws) from secure websites (https). No False","title":"WAGTAIL_LIVE_USE_SECURE_WS_CONNECTION"},{"location":"reference/settings/#synchronize-live-page-with-admin-interface","text":"","title":"Synchronize live page with admin interface"},{"location":"reference/settings/#wagtail_live_sync_with_admin","text":"Description Required Default This setting controls the synchronization of a live page when it's modified in the admin interface. No True When WAGTAIL_LIVE_SYNC_WITH_ADMIN is True (default), the admin interface can be used as a way to publish instantly to a live page. When it's False , changes made in the admin interface aren't automatically/live published. You can set the value of this setting to False if you don't intend to use the admin interface to publish/edit live posts. This will avoid making computations to track changes made in the admin interface.","title":"WAGTAIL_LIVE_SYNC_WITH_ADMIN"},{"location":"reference/utils/","text":"Utilities wagtail_live . utils . get_setting_or_raise ( setting , setting_str ) Retrieves and returns the value of a setting if present in user's settings, else raises an ImproperlyConfigured error. Parameters: Name Type Description Default setting str The name of the setting to find in user's settings. required setting_str str A verbose name for the setting when reporting errors. required Returns: Type Description str The value of the setting if defined in user's settings. Exceptions: Type Description ImproperlyConfigured If the setting isn't defined. Source code in wagtail_live/utils.py def get_setting_or_raise ( setting , setting_str ): \"\"\" Retrieves and returns the value of a setting if present in user's settings, else raises an `ImproperlyConfigured` error. Args: setting (str): The name of the setting to find in user's settings. setting_str (str): A verbose name for the setting when reporting errors. Returns: str: The value of the setting if defined in user's settings. Raises: ImproperlyConfigured: If the setting isn't defined. \"\"\" value = getattr ( settings , setting , \"\" ) if not value : err_msg = f \"You haven't specified a { setting_str } in your settings.\" raise ImproperlyConfigured ( err_msg ) return value wagtail_live . utils . get_live_page_model () Retrieves the live page model specified in user's settings. Returns: Type Description LivePageMixin The live page model specified. Exceptions: Type Description ImproperlyConfigured if no live page model is specified or the one specified doesn't inherit from wagtail_live.models.LivePageMixin . ImportError if the live page model class couldn't be loaded. Source code in wagtail_live/utils.py def get_live_page_model (): \"\"\" Retrieves the live page model specified in user's settings. Returns: LivePageMixin: The live page model specified. Raises: ImproperlyConfigured: if no live page model is specified or the one specified doesn't inherit from `wagtail_live.models.LivePageMixin`. ImportError: if the live page model class couldn't be loaded. \"\"\" from wagtail_live.models import LivePageMixin live_model_class = get_setting_or_raise ( setting = \"WAGTAIL_LIVE_PAGE_MODEL\" , setting_str = \"live page model\" ) model = import_string ( live_model_class ) if not issubclass ( model , LivePageMixin ): raise ImproperlyConfigured ( f \"The live page model { live_model_class } doesn't inherit from \" \"wagtail_live.models.LivePageMixin.\" ) return model wagtail_live . utils . get_live_receiver () Retrieves the live receiver specified in user's settings. Returns: Type Description BaseMessageReceiver The live receiver specified if found else None . Exceptions: Type Description ImproperlyConfigured if the receiver specified doesn't inherit from wagtail_live.receivers.BaseMessageReceiver . ImportError if the receiver class couldn't be loaded. Source code in wagtail_live/utils.py def get_live_receiver (): \"\"\" Retrieves the live receiver specified in user's settings. Returns: BaseMessageReceiver: The live receiver specified if found else `None`. Raises: ImproperlyConfigured: if the receiver specified doesn't inherit from `wagtail_live.receivers.BaseMessageReceiver`. ImportError: if the receiver class couldn't be loaded. \"\"\" from wagtail_live.receivers.base import BaseMessageReceiver live_receiver_class = getattr ( settings , \"WAGTAIL_LIVE_RECEIVER\" , \"\" ) if not live_receiver_class : # Assume live interface is used, in which case no additional setup is needed. return receiver = import_string ( live_receiver_class ) if not issubclass ( receiver , BaseMessageReceiver ): raise ImproperlyConfigured ( f \"The receiver { live_receiver_class } doesn't inherit from \" \"wagtail_live.receivers.BaseMessageReceiver.\" ) return receiver wagtail_live . utils . get_live_publisher () Retrieves the live publisher specified in user's settings. Returns: Type Description Publisher The live publisher specified. Exceptions: Type Description ImproperlyConfigured if no publisher class is specified in settings. ImportError if the publisher class couldn't be loaded. Source code in wagtail_live/utils.py def get_live_publisher (): \"\"\" Retrieves the live publisher specified in user's settings. Returns: Publisher: The live publisher specified. Raises: ImproperlyConfigured: if no publisher class is specified in settings. ImportError: if the publisher class couldn't be loaded. \"\"\" live_publisher_class = get_setting_or_raise ( setting = \"WAGTAIL_LIVE_PUBLISHER\" , setting_str = \"live publisher\" ) return import_string ( live_publisher_class ) wagtail_live . utils . get_polling_timeout () Retrieves the duration of the polling timeout for the long polling technique. The user can set this parameter in his settings by doing so: WAGTAIL_LIVE_POLLING_TIMEOUT = ( duration in seconds ) The default value is 60 seconds. Returns: Type Description int The duration of the polling timeout if defined else 60. Source code in wagtail_live/utils.py def get_polling_timeout (): \"\"\" Retrieves the duration of the polling timeout for the long polling technique. The user can set this parameter in his settings by doing so: ```python WAGTAIL_LIVE_POLLING_TIMEOUT = (duration in seconds) ``` The default value is 60 seconds. Returns: int: The duration of the polling timeout if defined else 60. \"\"\" return getattr ( settings , \"WAGTAIL_LIVE_POLLING_TIMEOUT\" , 60 ) wagtail_live . utils . get_polling_interval () Retrieves the duration of the polling interval for the interval polling technique. The user can set this parameter in his settings by doing so: WAGTAIL_LIVE_POLLING_INTERVAL = ( duration in ms ) The default value is 3000 milliseconds. Returns: Type Description int the duration of the polling interval if defined else 3000. Source code in wagtail_live/utils.py def get_polling_interval (): \"\"\" Retrieves the duration of the polling interval for the interval polling technique. The user can set this parameter in his settings by doing so: ```python WAGTAIL_LIVE_POLLING_INTERVAL = (duration in ms) ``` The default value is 3000 milliseconds. Returns: int: the duration of the polling interval if defined else 3000. \"\"\" return getattr ( settings , \"WAGTAIL_LIVE_POLLING_INTERVAL\" , 3000 ) wagtail_live . utils . is_embed ( text ) Checks if a text is a link to embed. Parameters: Name Type Description Default text str Text to check required Returns: Type Description bool True if text corresponds to an embed link. False else. Source code in wagtail_live/utils.py @lru_cache ( maxsize = None ) def is_embed ( text ): \"\"\" Checks if a text is a link to embed. Args: text (str): Text to check Returns: bool: - `True` if text corresponds to an embed link. - `False` else. \"\"\" for provider in all_providers : for url_pattern in provider . get ( \"urls\" , []): if bool ( re . match ( url_pattern , text )): return True return False","title":"Utilities"},{"location":"reference/utils/#utilities","text":"","title":"Utilities"},{"location":"reference/utils/#wagtail_live.utils.get_setting_or_raise","text":"Retrieves and returns the value of a setting if present in user's settings, else raises an ImproperlyConfigured error. Parameters: Name Type Description Default setting str The name of the setting to find in user's settings. required setting_str str A verbose name for the setting when reporting errors. required Returns: Type Description str The value of the setting if defined in user's settings. Exceptions: Type Description ImproperlyConfigured If the setting isn't defined. Source code in wagtail_live/utils.py def get_setting_or_raise ( setting , setting_str ): \"\"\" Retrieves and returns the value of a setting if present in user's settings, else raises an `ImproperlyConfigured` error. Args: setting (str): The name of the setting to find in user's settings. setting_str (str): A verbose name for the setting when reporting errors. Returns: str: The value of the setting if defined in user's settings. Raises: ImproperlyConfigured: If the setting isn't defined. \"\"\" value = getattr ( settings , setting , \"\" ) if not value : err_msg = f \"You haven't specified a { setting_str } in your settings.\" raise ImproperlyConfigured ( err_msg ) return value","title":"get_setting_or_raise()"},{"location":"reference/utils/#wagtail_live.utils.get_live_page_model","text":"Retrieves the live page model specified in user's settings. Returns: Type Description LivePageMixin The live page model specified. Exceptions: Type Description ImproperlyConfigured if no live page model is specified or the one specified doesn't inherit from wagtail_live.models.LivePageMixin . ImportError if the live page model class couldn't be loaded. Source code in wagtail_live/utils.py def get_live_page_model (): \"\"\" Retrieves the live page model specified in user's settings. Returns: LivePageMixin: The live page model specified. Raises: ImproperlyConfigured: if no live page model is specified or the one specified doesn't inherit from `wagtail_live.models.LivePageMixin`. ImportError: if the live page model class couldn't be loaded. \"\"\" from wagtail_live.models import LivePageMixin live_model_class = get_setting_or_raise ( setting = \"WAGTAIL_LIVE_PAGE_MODEL\" , setting_str = \"live page model\" ) model = import_string ( live_model_class ) if not issubclass ( model , LivePageMixin ): raise ImproperlyConfigured ( f \"The live page model { live_model_class } doesn't inherit from \" \"wagtail_live.models.LivePageMixin.\" ) return model","title":"get_live_page_model()"},{"location":"reference/utils/#wagtail_live.utils.get_live_receiver","text":"Retrieves the live receiver specified in user's settings. Returns: Type Description BaseMessageReceiver The live receiver specified if found else None . Exceptions: Type Description ImproperlyConfigured if the receiver specified doesn't inherit from wagtail_live.receivers.BaseMessageReceiver . ImportError if the receiver class couldn't be loaded. Source code in wagtail_live/utils.py def get_live_receiver (): \"\"\" Retrieves the live receiver specified in user's settings. Returns: BaseMessageReceiver: The live receiver specified if found else `None`. Raises: ImproperlyConfigured: if the receiver specified doesn't inherit from `wagtail_live.receivers.BaseMessageReceiver`. ImportError: if the receiver class couldn't be loaded. \"\"\" from wagtail_live.receivers.base import BaseMessageReceiver live_receiver_class = getattr ( settings , \"WAGTAIL_LIVE_RECEIVER\" , \"\" ) if not live_receiver_class : # Assume live interface is used, in which case no additional setup is needed. return receiver = import_string ( live_receiver_class ) if not issubclass ( receiver , BaseMessageReceiver ): raise ImproperlyConfigured ( f \"The receiver { live_receiver_class } doesn't inherit from \" \"wagtail_live.receivers.BaseMessageReceiver.\" ) return receiver","title":"get_live_receiver()"},{"location":"reference/utils/#wagtail_live.utils.get_live_publisher","text":"Retrieves the live publisher specified in user's settings. Returns: Type Description Publisher The live publisher specified. Exceptions: Type Description ImproperlyConfigured if no publisher class is specified in settings. ImportError if the publisher class couldn't be loaded. Source code in wagtail_live/utils.py def get_live_publisher (): \"\"\" Retrieves the live publisher specified in user's settings. Returns: Publisher: The live publisher specified. Raises: ImproperlyConfigured: if no publisher class is specified in settings. ImportError: if the publisher class couldn't be loaded. \"\"\" live_publisher_class = get_setting_or_raise ( setting = \"WAGTAIL_LIVE_PUBLISHER\" , setting_str = \"live publisher\" ) return import_string ( live_publisher_class )","title":"get_live_publisher()"},{"location":"reference/utils/#wagtail_live.utils.get_polling_timeout","text":"Retrieves the duration of the polling timeout for the long polling technique. The user can set this parameter in his settings by doing so: WAGTAIL_LIVE_POLLING_TIMEOUT = ( duration in seconds ) The default value is 60 seconds. Returns: Type Description int The duration of the polling timeout if defined else 60. Source code in wagtail_live/utils.py def get_polling_timeout (): \"\"\" Retrieves the duration of the polling timeout for the long polling technique. The user can set this parameter in his settings by doing so: ```python WAGTAIL_LIVE_POLLING_TIMEOUT = (duration in seconds) ``` The default value is 60 seconds. Returns: int: The duration of the polling timeout if defined else 60. \"\"\" return getattr ( settings , \"WAGTAIL_LIVE_POLLING_TIMEOUT\" , 60 )","title":"get_polling_timeout()"},{"location":"reference/utils/#wagtail_live.utils.get_polling_interval","text":"Retrieves the duration of the polling interval for the interval polling technique. The user can set this parameter in his settings by doing so: WAGTAIL_LIVE_POLLING_INTERVAL = ( duration in ms ) The default value is 3000 milliseconds. Returns: Type Description int the duration of the polling interval if defined else 3000. Source code in wagtail_live/utils.py def get_polling_interval (): \"\"\" Retrieves the duration of the polling interval for the interval polling technique. The user can set this parameter in his settings by doing so: ```python WAGTAIL_LIVE_POLLING_INTERVAL = (duration in ms) ``` The default value is 3000 milliseconds. Returns: int: the duration of the polling interval if defined else 3000. \"\"\" return getattr ( settings , \"WAGTAIL_LIVE_POLLING_INTERVAL\" , 3000 )","title":"get_polling_interval()"},{"location":"reference/utils/#wagtail_live.utils.is_embed","text":"Checks if a text is a link to embed. Parameters: Name Type Description Default text str Text to check required Returns: Type Description bool True if text corresponds to an embed link. False else. Source code in wagtail_live/utils.py @lru_cache ( maxsize = None ) def is_embed ( text ): \"\"\" Checks if a text is a link to embed. Args: text (str): Text to check Returns: bool: - `True` if text corresponds to an embed link. - `False` else. \"\"\" for provider in all_providers : for url_pattern in provider . get ( \"urls\" , []): if bool ( re . match ( url_pattern , text )): return True return False","title":"is_embed()"},{"location":"reference/publishers/base_websocket_publisher/","text":"Base Websocket Publisher wagtail_live.publishers.websocket.BaseWebsocketPublisher Base class for publishers using the websocket technique. __call__ ( self , sender , channel_id , renders , removals , ** kwargs ) special Listens to the live_page_update signal. Parameters: Name Type Description Default sender LivePageMixin Sender of the signal. required channel_id str ID of the channel corresponding to the updated page. required renders dict Dict containing the new posts and the edited posts of the updated page. required removals list List containing the id of the deleted posts for the updated page. required Source code in wagtail_live/publishers/websocket.py def __call__ ( self , sender , channel_id , renders , removals , ** kwargs ): \"\"\" Listens to the `live_page_update` signal. Args: sender (LivePageMixin): Sender of the signal. channel_id (str): ID of the channel corresponding to the updated page. renders (dict): Dict containing the new posts and the edited posts of the updated page. removals (list): List containing the id of the deleted posts for the updated page. \"\"\" renders = { post . id : { \"show\" : post . value [ \"show\" ], \"content\" : post . render ( context = { \"block_id\" : post . id }), } for post in renders } return self . publish ( channel_id = channel_id , renders = renders , removals = removals ) publish ( self , channel_id , renders , removals ) Sends a new update: to the channel_id \"group\" for django channels, to an event bus for separate websocket servers, to the service itself for hosted websocket services. Parameters: Name Type Description Default channel_id str ID of the channel corresponding to the updated page. required renders dict Dict containing the new posts and the edited posts of the updated page. required removals list List containing the id of the deleted posts for the updated page. required Source code in wagtail_live/publishers/websocket.py def publish ( self , channel_id , renders , removals ): \"\"\" Sends a new update: - to the `channel_id` \"group\" for django channels, - to an event bus for separate websocket servers, - to the service itself for hosted websocket services. Args: channel_id (str): ID of the channel corresponding to the updated page. renders (dict): Dict containing the new posts and the edited posts of the updated page. removals (list): List containing the id of the deleted posts for the updated page. \"\"\" raise NotImplementedError","title":"Base Websocket Publisher"},{"location":"reference/publishers/base_websocket_publisher/#base-websocket-publisher","text":"","title":"Base Websocket Publisher"},{"location":"reference/publishers/base_websocket_publisher/#wagtail_live.publishers.websocket.BaseWebsocketPublisher","text":"Base class for publishers using the websocket technique.","title":"BaseWebsocketPublisher"},{"location":"reference/publishers/base_websocket_publisher/#wagtail_live.publishers.websocket.BaseWebsocketPublisher.__call__","text":"Listens to the live_page_update signal. Parameters: Name Type Description Default sender LivePageMixin Sender of the signal. required channel_id str ID of the channel corresponding to the updated page. required renders dict Dict containing the new posts and the edited posts of the updated page. required removals list List containing the id of the deleted posts for the updated page. required Source code in wagtail_live/publishers/websocket.py def __call__ ( self , sender , channel_id , renders , removals , ** kwargs ): \"\"\" Listens to the `live_page_update` signal. Args: sender (LivePageMixin): Sender of the signal. channel_id (str): ID of the channel corresponding to the updated page. renders (dict): Dict containing the new posts and the edited posts of the updated page. removals (list): List containing the id of the deleted posts for the updated page. \"\"\" renders = { post . id : { \"show\" : post . value [ \"show\" ], \"content\" : post . render ( context = { \"block_id\" : post . id }), } for post in renders } return self . publish ( channel_id = channel_id , renders = renders , removals = removals )","title":"__call__()"},{"location":"reference/publishers/base_websocket_publisher/#wagtail_live.publishers.websocket.BaseWebsocketPublisher.publish","text":"Sends a new update: to the channel_id \"group\" for django channels, to an event bus for separate websocket servers, to the service itself for hosted websocket services. Parameters: Name Type Description Default channel_id str ID of the channel corresponding to the updated page. required renders dict Dict containing the new posts and the edited posts of the updated page. required removals list List containing the id of the deleted posts for the updated page. required Source code in wagtail_live/publishers/websocket.py def publish ( self , channel_id , renders , removals ): \"\"\" Sends a new update: - to the `channel_id` \"group\" for django channels, - to an event bus for separate websocket servers, - to the service itself for hosted websocket services. Args: channel_id (str): ID of the channel corresponding to the updated page. renders (dict): Dict containing the new posts and the edited posts of the updated page. removals (list): List containing the id of the deleted posts for the updated page. \"\"\" raise NotImplementedError","title":"publish()"},{"location":"reference/publishers/interval-polling/","text":"Interval Polling wagtail_live.publishers.polling.IntervalPollingPublisher Interval polling Publisher. Class Based View. This class handles delivering new updates to the client side (Interval polling technique). It accepts 3 request methods (POST, HEAD and GET) which correspond to the following steps: The client side initiates (shake) the communication by sending a POST request. The publisher acknowledges by sending relevant data to the client side. The client side asks if there are any updates by sending a HEAD request. If no updates are available, client side sleeps for the duration of the polling interval and repeats this step. If new updates are available, client side sends a GET request to get the new updates. get ( self , request , channel_id , * args , ** kwargs ) See base class. Source code in wagtail_live/publishers/polling.py def get ( self , request , channel_id , * args , ** kwargs ): \"\"\"See base class.\"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) last_update_client = self . get_last_update_client_from_request ( request = request ) tz = timezone . utc if settings . USE_TZ else None updated_posts , current_posts = live_page . get_updates_since ( last_update_ts = datetime . fromtimestamp ( last_update_client , tz = tz ), ) return JsonResponse ( { \"updates\" : updated_posts , \"currentPosts\" : current_posts , \"lastUpdateTimestamp\" : live_page . last_update_timestamp , } ) head ( self , request , channel_id , * args , ** kwargs ) Sends the timestamp of the last update for the page requested. Parameters: Name Type Description Default request HttpRequest Client side's request required channel_id str Id of the channel to get last update's timestamp from. required Returns: Type Description HttpResponse OK: if a page corresponding to the channel_id given exists. The timestamp of the last update for the page requested is sent in the response. Client side checks if this value is greater than the last one received. In such case, the client side knows that new updates are available and sends a GET request to get those updates. Http404: else. Source code in wagtail_live/publishers/polling.py def head ( self , request , channel_id , * args , ** kwargs ): \"\"\" Sends the timestamp of the last update for the page requested. Args: request (HttpRequest): Client side's request channel_id (str): Id of the channel to get last update's timestamp from. Returns: HttpResponse: - OK: if a page corresponding to the `channel_id` given exists. The timestamp of the last update for the page requested is sent in the response. Client side checks if this value is greater than the last one received. In such case, the client side knows that new updates are available and sends a GET request to get those updates. - Http404: else. \"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) response = JsonResponse ( data = {}, status = 200 ) response [ \"Last-Update-At\" ] = live_page . last_update_timestamp return response post ( self , request , channel_id , * args , ** kwargs ) See base class. Source code in wagtail_live/publishers/polling.py def post ( self , request , channel_id , * args , ** kwargs ): \"\"\"See base class.\"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) return JsonResponse ( { \"livePosts\" : [ live_post . id for live_post in live_page . live_posts ], \"lastUpdateTimestamp\" : live_page . last_update_timestamp , \"pollingInterval\" : get_polling_interval (), } )","title":"Interval polling"},{"location":"reference/publishers/interval-polling/#interval-polling","text":"","title":"Interval Polling"},{"location":"reference/publishers/interval-polling/#wagtail_live.publishers.polling.IntervalPollingPublisher","text":"Interval polling Publisher. Class Based View. This class handles delivering new updates to the client side (Interval polling technique). It accepts 3 request methods (POST, HEAD and GET) which correspond to the following steps: The client side initiates (shake) the communication by sending a POST request. The publisher acknowledges by sending relevant data to the client side. The client side asks if there are any updates by sending a HEAD request. If no updates are available, client side sleeps for the duration of the polling interval and repeats this step. If new updates are available, client side sends a GET request to get the new updates.","title":"IntervalPollingPublisher"},{"location":"reference/publishers/interval-polling/#wagtail_live.publishers.polling.IntervalPollingPublisher.get","text":"See base class. Source code in wagtail_live/publishers/polling.py def get ( self , request , channel_id , * args , ** kwargs ): \"\"\"See base class.\"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) last_update_client = self . get_last_update_client_from_request ( request = request ) tz = timezone . utc if settings . USE_TZ else None updated_posts , current_posts = live_page . get_updates_since ( last_update_ts = datetime . fromtimestamp ( last_update_client , tz = tz ), ) return JsonResponse ( { \"updates\" : updated_posts , \"currentPosts\" : current_posts , \"lastUpdateTimestamp\" : live_page . last_update_timestamp , } )","title":"get()"},{"location":"reference/publishers/interval-polling/#wagtail_live.publishers.polling.IntervalPollingPublisher.head","text":"Sends the timestamp of the last update for the page requested. Parameters: Name Type Description Default request HttpRequest Client side's request required channel_id str Id of the channel to get last update's timestamp from. required Returns: Type Description HttpResponse OK: if a page corresponding to the channel_id given exists. The timestamp of the last update for the page requested is sent in the response. Client side checks if this value is greater than the last one received. In such case, the client side knows that new updates are available and sends a GET request to get those updates. Http404: else. Source code in wagtail_live/publishers/polling.py def head ( self , request , channel_id , * args , ** kwargs ): \"\"\" Sends the timestamp of the last update for the page requested. Args: request (HttpRequest): Client side's request channel_id (str): Id of the channel to get last update's timestamp from. Returns: HttpResponse: - OK: if a page corresponding to the `channel_id` given exists. The timestamp of the last update for the page requested is sent in the response. Client side checks if this value is greater than the last one received. In such case, the client side knows that new updates are available and sends a GET request to get those updates. - Http404: else. \"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) response = JsonResponse ( data = {}, status = 200 ) response [ \"Last-Update-At\" ] = live_page . last_update_timestamp return response","title":"head()"},{"location":"reference/publishers/interval-polling/#wagtail_live.publishers.polling.IntervalPollingPublisher.post","text":"See base class. Source code in wagtail_live/publishers/polling.py def post ( self , request , channel_id , * args , ** kwargs ): \"\"\"See base class.\"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) return JsonResponse ( { \"livePosts\" : [ live_post . id for live_post in live_page . live_posts ], \"lastUpdateTimestamp\" : live_page . last_update_timestamp , \"pollingInterval\" : get_polling_interval (), } )","title":"post()"},{"location":"reference/publishers/long-polling/","text":"Long Polling wagtail_live.publishers.polling.LongPollingPublisher Long polling Publisher. Class Based View. This class handles delivering new updates to the client side (Long polling technique). It accepts 2 request methods (POST and GET) which correspond to the following steps: The client side initiates (shake) the communication by sending a POST request. The publisher acknowledges by sending relevant data to the client side. The client side asks new updates by sending a GET request. Server side keeps the connection open until a new update is available. In that case, updates are directly sent to client side. If the polling timeout duration is reached, it sends a response containing a timeOutReached parameter which indicates the client side that there aren't updates available. get ( self , request , channel_id , * args , ** kwargs ) Sends updates when they are available as long as the polling timeout isn't reached. See base class. Source code in wagtail_live/publishers/polling.py def get ( self , request , channel_id , * args , ** kwargs ): \"\"\" Sends updates when they are available as long as the polling timeout isn't reached. See base class. \"\"\" last_update_client = self . get_last_update_client_from_request ( request = request ) polling_timeout = get_polling_timeout () starting_time = time . time () while time . time () - starting_time < polling_timeout : live_page = get_object_or_404 ( self . model , channel_id = channel_id ) last_update_ts = live_page . last_update_timestamp if last_update_ts > last_update_client : tz = timezone . utc if settings . USE_TZ else None updated_posts , current_posts = live_page . get_updates_since ( last_update_ts = datetime . fromtimestamp ( last_update_client , tz = tz ), ) return JsonResponse ( { \"updates\" : updated_posts , \"currentPosts\" : current_posts , \"lastUpdateTimestamp\" : last_update_ts , } ) # Maybe propose a setting so the user can define this value time . sleep ( 0.5 ) return JsonResponse ({ \"timeOutReached\" : \"Timeout duration reached.\" }) post ( self , request , channel_id , * args , ** kwargs ) See base class. Source code in wagtail_live/publishers/polling.py def post ( self , request , channel_id , * args , ** kwargs ): \"\"\"See base class.\"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) return JsonResponse ( { \"livePosts\" : [ live_post . id for live_post in live_page . live_posts ], \"lastUpdateTimestamp\" : live_page . last_update_timestamp , } )","title":"Long polling"},{"location":"reference/publishers/long-polling/#long-polling","text":"","title":"Long Polling"},{"location":"reference/publishers/long-polling/#wagtail_live.publishers.polling.LongPollingPublisher","text":"Long polling Publisher. Class Based View. This class handles delivering new updates to the client side (Long polling technique). It accepts 2 request methods (POST and GET) which correspond to the following steps: The client side initiates (shake) the communication by sending a POST request. The publisher acknowledges by sending relevant data to the client side. The client side asks new updates by sending a GET request. Server side keeps the connection open until a new update is available. In that case, updates are directly sent to client side. If the polling timeout duration is reached, it sends a response containing a timeOutReached parameter which indicates the client side that there aren't updates available.","title":"LongPollingPublisher"},{"location":"reference/publishers/long-polling/#wagtail_live.publishers.polling.LongPollingPublisher.get","text":"Sends updates when they are available as long as the polling timeout isn't reached. See base class. Source code in wagtail_live/publishers/polling.py def get ( self , request , channel_id , * args , ** kwargs ): \"\"\" Sends updates when they are available as long as the polling timeout isn't reached. See base class. \"\"\" last_update_client = self . get_last_update_client_from_request ( request = request ) polling_timeout = get_polling_timeout () starting_time = time . time () while time . time () - starting_time < polling_timeout : live_page = get_object_or_404 ( self . model , channel_id = channel_id ) last_update_ts = live_page . last_update_timestamp if last_update_ts > last_update_client : tz = timezone . utc if settings . USE_TZ else None updated_posts , current_posts = live_page . get_updates_since ( last_update_ts = datetime . fromtimestamp ( last_update_client , tz = tz ), ) return JsonResponse ( { \"updates\" : updated_posts , \"currentPosts\" : current_posts , \"lastUpdateTimestamp\" : last_update_ts , } ) # Maybe propose a setting so the user can define this value time . sleep ( 0.5 ) return JsonResponse ({ \"timeOutReached\" : \"Timeout duration reached.\" })","title":"get()"},{"location":"reference/publishers/long-polling/#wagtail_live.publishers.polling.LongPollingPublisher.post","text":"See base class. Source code in wagtail_live/publishers/polling.py def post ( self , request , channel_id , * args , ** kwargs ): \"\"\"See base class.\"\"\" live_page = get_object_or_404 ( self . model , channel_id = channel_id ) return JsonResponse ( { \"livePosts\" : [ live_post . id for live_post in live_page . live_posts ], \"lastUpdateTimestamp\" : live_page . last_update_timestamp , } )","title":"post()"},{"location":"reference/publishers/polling-mixin/","text":"Polling Mixin wagtail_live.publishers.polling.PollingPublisherMixin A mixin for publishers using the polling technique. Attributes: Name Type Description url_path str Path of the URL used by client side to fetch new updates. url_name str Name of the URL for reversing/resolving. get ( self , request , channel_id , * args , ** kwargs ) Retrieves and sends new updates to the client side. Parameters: Name Type Description Default request HttpRequest Client side's request sent along with the timestamp of the last update received. required channel_id str Id of the channel to get last update's timestamp from. required Returns: Type Description HttpResponse JSONResponse with the following informations: A mapping of the live posts updated since client side's last update timestamp. Keys represents IDs of the live posts edited and the values are the new content of those live posts. A list of the IDs of the current live posts for the page requested. Client side compares this list to the one it has and remove the live posts whose IDs aren't in this new list. Timestamp of the last update for the page requested. if a page corresponding to the channel_id given exists. Http404 else. Source code in wagtail_live/publishers/polling.py def get ( self , request , channel_id , * args , ** kwargs ): \"\"\" Retrieves and sends new updates to the client side. Args: request (HttpRequest): Client side's request sent along with the timestamp of the last update received. channel_id (str): Id of the channel to get last update's timestamp from. Returns: HttpResponse: - JSONResponse with the following informations: - A mapping of the live posts updated since client side's last update timestamp. Keys represents IDs of the live posts edited and the values are the new content of those live posts. - A list of the IDs of the current live posts for the page requested. Client side compares this list to the one it has and remove the live posts whose IDs aren't in this new list. - Timestamp of the last update for the page requested. if a page corresponding to the `channel_id` given exists. - Http404 else. \"\"\" raise NotImplementedError get_last_update_client_from_request ( request ) staticmethod Retrieves the timestamp of the last update received in the client side. Parameters: Name Type Description Default request HttpRequest client side request required Returns: Type Description float Timestamp of the last update received in the client side. Source code in wagtail_live/publishers/polling.py @staticmethod def get_last_update_client_from_request ( request ): \"\"\" Retrieves the timestamp of the last update received in the client side. Args: request (HttpRequest): client side request Returns: float: Timestamp of the last update received in the client side. \"\"\" return float ( request . GET . get ( \"last_update_ts\" )) get_urls () classmethod Retrieves the URLs client side uses to fetch updates. Source code in wagtail_live/publishers/polling.py @classmethod def get_urls ( cls ): \"\"\"Retrieves the URLs client side uses to fetch updates.\"\"\" return [ path ( cls . url_path , cls . as_view (), name = cls . url_name ), ] post ( self , request , channel_id , * args , ** kwargs ) Initiates communication with client side and sends current live posts. Parameters: Name Type Description Default request HttpRequest Client side's request required channel_id str Id of the channel to get updates from. required Returns: Type Description HttpResponse JSONResponse with the following informations: A list of the IDs of the current live posts for the page requested. Client side uses this list to keep track of live posts that have been deleted. Timestamp of the last update for the page requested. Client side uses this to know when new updates are available. The duration of the polling interval for interval polling. if a page corresponding to the channel_id given exists. Http404 else. Source code in wagtail_live/publishers/polling.py def post ( self , request , channel_id , * args , ** kwargs ): \"\"\" Initiates communication with client side and sends current live posts. Args: request (HttpRequest): Client side's request channel_id (str): Id of the channel to get updates from. Returns: HttpResponse: - JSONResponse with the following informations: - A list of the IDs of the current live posts for the page requested. Client side uses this list to keep track of live posts that have been deleted. - Timestamp of the last update for the page requested. Client side uses this to know when new updates are available. - The duration of the polling interval for interval polling. if a page corresponding to the `channel_id` given exists. - Http404 else. \"\"\" raise NotImplementedError","title":"Polling publisher mixin"},{"location":"reference/publishers/polling-mixin/#polling-mixin","text":"","title":"Polling Mixin"},{"location":"reference/publishers/polling-mixin/#wagtail_live.publishers.polling.PollingPublisherMixin","text":"A mixin for publishers using the polling technique. Attributes: Name Type Description url_path str Path of the URL used by client side to fetch new updates. url_name str Name of the URL for reversing/resolving.","title":"PollingPublisherMixin"},{"location":"reference/publishers/polling-mixin/#wagtail_live.publishers.polling.PollingPublisherMixin.get","text":"Retrieves and sends new updates to the client side. Parameters: Name Type Description Default request HttpRequest Client side's request sent along with the timestamp of the last update received. required channel_id str Id of the channel to get last update's timestamp from. required Returns: Type Description HttpResponse JSONResponse with the following informations: A mapping of the live posts updated since client side's last update timestamp. Keys represents IDs of the live posts edited and the values are the new content of those live posts. A list of the IDs of the current live posts for the page requested. Client side compares this list to the one it has and remove the live posts whose IDs aren't in this new list. Timestamp of the last update for the page requested. if a page corresponding to the channel_id given exists. Http404 else. Source code in wagtail_live/publishers/polling.py def get ( self , request , channel_id , * args , ** kwargs ): \"\"\" Retrieves and sends new updates to the client side. Args: request (HttpRequest): Client side's request sent along with the timestamp of the last update received. channel_id (str): Id of the channel to get last update's timestamp from. Returns: HttpResponse: - JSONResponse with the following informations: - A mapping of the live posts updated since client side's last update timestamp. Keys represents IDs of the live posts edited and the values are the new content of those live posts. - A list of the IDs of the current live posts for the page requested. Client side compares this list to the one it has and remove the live posts whose IDs aren't in this new list. - Timestamp of the last update for the page requested. if a page corresponding to the `channel_id` given exists. - Http404 else. \"\"\" raise NotImplementedError","title":"get()"},{"location":"reference/publishers/polling-mixin/#wagtail_live.publishers.polling.PollingPublisherMixin.get_last_update_client_from_request","text":"Retrieves the timestamp of the last update received in the client side. Parameters: Name Type Description Default request HttpRequest client side request required Returns: Type Description float Timestamp of the last update received in the client side. Source code in wagtail_live/publishers/polling.py @staticmethod def get_last_update_client_from_request ( request ): \"\"\" Retrieves the timestamp of the last update received in the client side. Args: request (HttpRequest): client side request Returns: float: Timestamp of the last update received in the client side. \"\"\" return float ( request . GET . get ( \"last_update_ts\" ))","title":"get_last_update_client_from_request()"},{"location":"reference/publishers/polling-mixin/#wagtail_live.publishers.polling.PollingPublisherMixin.get_urls","text":"Retrieves the URLs client side uses to fetch updates. Source code in wagtail_live/publishers/polling.py @classmethod def get_urls ( cls ): \"\"\"Retrieves the URLs client side uses to fetch updates.\"\"\" return [ path ( cls . url_path , cls . as_view (), name = cls . url_name ), ]","title":"get_urls()"},{"location":"reference/publishers/polling-mixin/#wagtail_live.publishers.polling.PollingPublisherMixin.post","text":"Initiates communication with client side and sends current live posts. Parameters: Name Type Description Default request HttpRequest Client side's request required channel_id str Id of the channel to get updates from. required Returns: Type Description HttpResponse JSONResponse with the following informations: A list of the IDs of the current live posts for the page requested. Client side uses this list to keep track of live posts that have been deleted. Timestamp of the last update for the page requested. Client side uses this to know when new updates are available. The duration of the polling interval for interval polling. if a page corresponding to the channel_id given exists. Http404 else. Source code in wagtail_live/publishers/polling.py def post ( self , request , channel_id , * args , ** kwargs ): \"\"\" Initiates communication with client side and sends current live posts. Args: request (HttpRequest): Client side's request channel_id (str): Id of the channel to get updates from. Returns: HttpResponse: - JSONResponse with the following informations: - A list of the IDs of the current live posts for the page requested. Client side uses this list to keep track of live posts that have been deleted. - Timestamp of the last update for the page requested. Client side uses this to know when new updates are available. - The duration of the polling interval for interval polling. if a page corresponding to the `channel_id` given exists. - Http404 else. \"\"\" raise NotImplementedError","title":"post()"},{"location":"reference/receivers/base-message-receiver/","text":"Base Message Receiver wagtail_live.receivers.base.BaseMessageReceiver Base Receiver class. add_message ( self , message ) Adds a received message from a messaging app to the live page corresponding to the channel where the message was posted if such a page exists. Parameters: Name Type Description Default message dict A message received from a messaging app. required Source code in wagtail_live/receivers/base.py def add_message ( self , message ): \"\"\" Adds a received message from a messaging app to the live page corresponding to the channel where the message was posted if such a page exists. Args: message (dict): A message received from a messaging app. \"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_message ( message = message ) live_post = construct_live_post_block ( message_id = message_id , created = now ()) message_text = self . get_message_text ( message = message ) self . process_text ( live_post = live_post , message_text = message_text ) files = self . get_message_files ( message = message ) self . process_files ( live_post = live_post , files = files ) live_page . add_live_post ( live_post = live_post ) change_message ( self , message ) Changes an edited message in a messaging app in the live page corresponding to the channel where the message was posted if such a page exists. Parameters: Name Type Description Default message dict A message edited from a messaging app. required Source code in wagtail_live/receivers/base.py def change_message ( self , message ): \"\"\" Changes an edited message in a messaging app in the live page corresponding to the channel where the message was posted if such a page exists. Args: message (dict): A message edited from a messaging app. \"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_edited_message ( message = message ) live_post = live_page . get_live_post_by_message_id ( message_id = message_id ) clear_live_post_content ( live_post = live_post ) message_text = self . get_message_text_from_edited_message ( message = message ) self . process_text ( live_post = live_post . value , message_text = message_text ) files = self . get_message_files_from_edited_message ( message = message ) self . process_files ( live_post = live_post . value , files = files ) live_page . update_live_post ( live_post = live_post ) delete_message ( self , message ) Deletes a message in the live page corresponding to the channel where the message was posted if such a page exists. Parameters: Name Type Description Default message dict A message deleted from a messaging app. required Source code in wagtail_live/receivers/base.py def delete_message ( self , message ): \"\"\" Deletes a message in the live page corresponding to the channel where the message was posted if such a page exists. Args: message (dict): A message deleted from a messaging app. \"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_edited_message ( message = message ) try : live_page . delete_live_post ( message_id = message_id ) except KeyError : logger . warning ( f \"Couldn't delete message with id= { message_id } . \\n \" \"This may be due for 2 reasons: \\n \" \"1- The post hasn't been saved on the live page. \\n \" \"2- The post has been deleted in the admin interface. \\n \" ) dispatch_event ( self , event ) Dispatches an event to find the corresponding handler. Parameters: Name Type Description Default event dict New event from a messaging app. required Source code in wagtail_live/receivers/base.py def dispatch_event ( self , event ): \"\"\" Dispatches an event to find the corresponding handler. Args: event (dict): New event from a messaging app. \"\"\" raise NotImplementedError get_channel_id_from_message ( self , message ) Retrieves a channel ID from a message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description str ID of the channel which the given message belongs to. Source code in wagtail_live/receivers/base.py def get_channel_id_from_message ( self , message ): \"\"\" Retrieves a channel ID from a message. Args: message (dict): A received message from a messaging app. Returns: str: ID of the channel which the given message belongs to. \"\"\" raise NotImplementedError get_embed ( self , text ) Checks if a text is an embed for this receiver and return embed URL if so. Parameters: Name Type Description Default text str Text to check. required Returns: Type Description str URL of the embed if the text contains an embed, else \"\" . Source code in wagtail_live/receivers/base.py def get_embed ( self , text ): \"\"\" Checks if a text is an embed for this receiver and return embed URL if so. Args: text (str): Text to check. Returns: str: URL of the embed if the text contains an embed, else `\"\"`. \"\"\" return text if is_embed ( text = text ) else \"\" get_image_content ( self , image ) Retrieves the content of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description File Content of the image. Source code in wagtail_live/receivers/base.py def get_image_content ( self , image ): \"\"\" Retrieves the content of an image. Args: image (dict): Informations about an image Returns: File: Content of the image. \"\"\" raise NotImplementedError get_image_dimensions ( self , image ) Retrieves the width and height of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description (int, int) Width and height of the image. Exceptions: Type Description ValueError if the width and height of the image can't be retrieved. Source code in wagtail_live/receivers/base.py def get_image_dimensions ( self , image ): \"\"\" Retrieves the width and height of an image. Args: image (dict): Informations about an image Returns: (int, int): Width and height of the image. Raises: ValueError: if the width and height of the image can't be retrieved. \"\"\" raise NotImplementedError get_image_mimetype ( self , image ) Retrieves the mimetype of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description str Mimetype of the image. Source code in wagtail_live/receivers/base.py def get_image_mimetype ( self , image ): \"\"\" Retrieves the mimetype of an image. Args: image (dict): Informations about an image Returns: str: Mimetype of the image. \"\"\" raise NotImplementedError get_image_name ( self , image ) Retrieves the name of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description str Name of the image. Source code in wagtail_live/receivers/base.py def get_image_name ( self , image ): \"\"\" Retrieves the name of an image. Args: image (dict): Informations about an image Returns: str: Name of the image. \"\"\" raise NotImplementedError get_image_title ( self , image ) Retrieves the title of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description str Title of the image. Source code in wagtail_live/receivers/base.py def get_image_title ( self , image ): \"\"\" Retrieves the title of an image. Args: image (dict): Informations about an image Returns: str: Title of the image. \"\"\" raise NotImplementedError get_live_page_from_channel_id ( self , channel_id ) Retrieves the live page with a given channel ID. Parameters: Name Type Description Default channel_id str Channel ID required Returns: Type Description LivePageMixin The livepage corresponding to channel_id . Exceptions: Type Description Http404 if a page with the given channel_id doesn't exist. Source code in wagtail_live/receivers/base.py def get_live_page_from_channel_id ( self , channel_id ): \"\"\" Retrieves the live page with a given channel ID. Args: channel_id (str): Channel ID Returns: LivePageMixin: The livepage corresponding to `channel_id`. Raises: Http404: if a page with the given `channel_id` doesn't exist. \"\"\" return self . model . objects . get ( channel_id = channel_id ) get_message_files ( self , message ) Retrieves the files of a message. A message is made of text and files. Parameters: Name Type Description Default message dict A received message from a messaging app required Returns: Type Description list Files included in the given message. Source code in wagtail_live/receivers/base.py def get_message_files ( self , message ): \"\"\" Retrieves the files of a message. A message is made of text and files. Args: message (dict): A received message from a messaging app Returns: list: Files included in the given message. \"\"\" raise NotImplementedError get_message_files_from_edited_message ( self , message ) Retrieves the files from an edited message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description list Files of the edited message. Source code in wagtail_live/receivers/base.py def get_message_files_from_edited_message ( self , message ): \"\"\" Retrieves the files from an edited message. Args: message (dict): A received message from a messaging app. Returns: list: Files of the edited message. \"\"\" raise NotImplementedError get_message_id_from_edited_message ( self , message ) Retrieves the ID of the original message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description str ID of the original message that is being edited. Source code in wagtail_live/receivers/base.py def get_message_id_from_edited_message ( self , message ): \"\"\" Retrieves the ID of the original message. Args: message (dict): A received message from a messaging app. Returns: str: ID of the original message that is being edited. \"\"\" raise NotImplementedError get_message_id_from_message ( self , message ) Retrieves message's ID. Parameters: Name Type Description Default message dict A received message from a messaging app required Returns: Type Description str Id of the given message Source code in wagtail_live/receivers/base.py def get_message_id_from_message ( self , message ): \"\"\" Retrieves message's ID. Args: message (dict): A received message from a messaging app Returns: str: Id of the given message \"\"\" raise NotImplementedError get_message_text ( self , message ) Retrieves the text of a message. A message is made of text and files. Parameters: Name Type Description Default message dict A received message from a messaging app required Returns: Type Description str Text of the given message. Source code in wagtail_live/receivers/base.py def get_message_text ( self , message ): \"\"\" Retrieves the text of a message. A message is made of text and files. Args: message (dict): A received message from a messaging app Returns: str: Text of the given message. \"\"\" raise NotImplementedError get_message_text_from_edited_message ( self , message ) Retrieves the text an edited message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description str Text of the edited message. Source code in wagtail_live/receivers/base.py def get_message_text_from_edited_message ( self , message ): \"\"\" Retrieves the text an edited message. Args: message (dict): A received message from a messaging app. Returns: str: Text of the edited message. \"\"\" raise NotImplementedError parse_text ( self , text ) Parses a raw text content according to the input source formatting rules. Parameters: Name Type Description Default text str a text. required Returns: Type Description str the actual content of the text. (Returns the text itself by default). Source code in wagtail_live/receivers/base.py def parse_text ( self , text ): \"\"\" Parses a raw text content according to the input source formatting rules. Args: text (str): a text. Returns: str: the actual content of the text. (Returns the text itself by default). \"\"\" return text process_files ( self , live_post , files ) Processes the files of a message. Creates the corresponding block for any file and adds it to the given live post. Parameters: Name Type Description Default live_post LivePostBlock Live post to update. required files list Files to add to a live post. required Source code in wagtail_live/receivers/base.py def process_files ( self , live_post , files ): \"\"\" Processes the files of a message. Creates the corresponding block for any file and adds it to the given live post. Args: live_post (LivePostBlock): Live post to update. files (list): Files to add to a live post. \"\"\" for item in files : image_title = self . get_image_title ( image = item ) try : image_width , image_height = self . get_image_dimensions ( image = item ) except ValueError : logger . error ( f \"Unable to retrieve the dimensions of { image_title } \" ) continue mime_type = self . get_image_mimetype ( image = item ) if mime_type not in SUPPORTED_MIME_TYPES : logger . error ( f \"Couldn't upload { image_title } . \" + f \"Images of type { mime_type } aren't supported yet.\" ) continue image = get_image_model ()( title = image_title , width = image_width , height = image_height , ) image_content = self . get_image_content ( image = item ) image_name = self . get_image_name ( image = item ) image . file . save ( name = image_name , content = image_content , save = True ) block = construct_image_block ( image = image ) add_block_to_live_post ( block_type = IMAGE , block = block , live_block = live_post , ) process_text ( self , live_post , message_text ) Processes the text of a message. Parses the message, constructs corresponding block types i.e Embed or Text and add those blocks to the given live post. Parameters: Name Type Description Default live_post LivePostBlock Live post to update. required message_text str Text to add to a live post. required Source code in wagtail_live/receivers/base.py def process_text ( self , live_post , message_text ): \"\"\" Processes the text of a message. Parses the message, constructs corresponding block types i.e Embed or Text and add those blocks to the given live post. Args: live_post (LivePostBlock): Live post to update. message_text (str): Text to add to a live post. \"\"\" message_parts = message_text . split ( \" \\n \" ) for text in message_parts : # Avoid creating a block for empty content text = text . strip () if not text : continue block_type = \"\" url = self . get_embed ( text = text ) if url : block = construct_embed_block ( url = url ) block_type = EMBED else : text_content = self . parse_text ( text = text ) block = construct_text_block ( text = text_content ) block_type = TEXT add_block_to_live_post ( block_type = block_type , block = block , live_block = live_post , )","title":"BaseMessageReceiver"},{"location":"reference/receivers/base-message-receiver/#base-message-receiver","text":"","title":"Base Message Receiver"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver","text":"Base Receiver class.","title":"BaseMessageReceiver"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.add_message","text":"Adds a received message from a messaging app to the live page corresponding to the channel where the message was posted if such a page exists. Parameters: Name Type Description Default message dict A message received from a messaging app. required Source code in wagtail_live/receivers/base.py def add_message ( self , message ): \"\"\" Adds a received message from a messaging app to the live page corresponding to the channel where the message was posted if such a page exists. Args: message (dict): A message received from a messaging app. \"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_message ( message = message ) live_post = construct_live_post_block ( message_id = message_id , created = now ()) message_text = self . get_message_text ( message = message ) self . process_text ( live_post = live_post , message_text = message_text ) files = self . get_message_files ( message = message ) self . process_files ( live_post = live_post , files = files ) live_page . add_live_post ( live_post = live_post )","title":"add_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.change_message","text":"Changes an edited message in a messaging app in the live page corresponding to the channel where the message was posted if such a page exists. Parameters: Name Type Description Default message dict A message edited from a messaging app. required Source code in wagtail_live/receivers/base.py def change_message ( self , message ): \"\"\" Changes an edited message in a messaging app in the live page corresponding to the channel where the message was posted if such a page exists. Args: message (dict): A message edited from a messaging app. \"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_edited_message ( message = message ) live_post = live_page . get_live_post_by_message_id ( message_id = message_id ) clear_live_post_content ( live_post = live_post ) message_text = self . get_message_text_from_edited_message ( message = message ) self . process_text ( live_post = live_post . value , message_text = message_text ) files = self . get_message_files_from_edited_message ( message = message ) self . process_files ( live_post = live_post . value , files = files ) live_page . update_live_post ( live_post = live_post )","title":"change_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.delete_message","text":"Deletes a message in the live page corresponding to the channel where the message was posted if such a page exists. Parameters: Name Type Description Default message dict A message deleted from a messaging app. required Source code in wagtail_live/receivers/base.py def delete_message ( self , message ): \"\"\" Deletes a message in the live page corresponding to the channel where the message was posted if such a page exists. Args: message (dict): A message deleted from a messaging app. \"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_edited_message ( message = message ) try : live_page . delete_live_post ( message_id = message_id ) except KeyError : logger . warning ( f \"Couldn't delete message with id= { message_id } . \\n \" \"This may be due for 2 reasons: \\n \" \"1- The post hasn't been saved on the live page. \\n \" \"2- The post has been deleted in the admin interface. \\n \" )","title":"delete_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.dispatch_event","text":"Dispatches an event to find the corresponding handler. Parameters: Name Type Description Default event dict New event from a messaging app. required Source code in wagtail_live/receivers/base.py def dispatch_event ( self , event ): \"\"\" Dispatches an event to find the corresponding handler. Args: event (dict): New event from a messaging app. \"\"\" raise NotImplementedError","title":"dispatch_event()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_channel_id_from_message","text":"Retrieves a channel ID from a message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description str ID of the channel which the given message belongs to. Source code in wagtail_live/receivers/base.py def get_channel_id_from_message ( self , message ): \"\"\" Retrieves a channel ID from a message. Args: message (dict): A received message from a messaging app. Returns: str: ID of the channel which the given message belongs to. \"\"\" raise NotImplementedError","title":"get_channel_id_from_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_embed","text":"Checks if a text is an embed for this receiver and return embed URL if so. Parameters: Name Type Description Default text str Text to check. required Returns: Type Description str URL of the embed if the text contains an embed, else \"\" . Source code in wagtail_live/receivers/base.py def get_embed ( self , text ): \"\"\" Checks if a text is an embed for this receiver and return embed URL if so. Args: text (str): Text to check. Returns: str: URL of the embed if the text contains an embed, else `\"\"`. \"\"\" return text if is_embed ( text = text ) else \"\"","title":"get_embed()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_image_content","text":"Retrieves the content of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description File Content of the image. Source code in wagtail_live/receivers/base.py def get_image_content ( self , image ): \"\"\" Retrieves the content of an image. Args: image (dict): Informations about an image Returns: File: Content of the image. \"\"\" raise NotImplementedError","title":"get_image_content()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_image_dimensions","text":"Retrieves the width and height of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description (int, int) Width and height of the image. Exceptions: Type Description ValueError if the width and height of the image can't be retrieved. Source code in wagtail_live/receivers/base.py def get_image_dimensions ( self , image ): \"\"\" Retrieves the width and height of an image. Args: image (dict): Informations about an image Returns: (int, int): Width and height of the image. Raises: ValueError: if the width and height of the image can't be retrieved. \"\"\" raise NotImplementedError","title":"get_image_dimensions()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_image_mimetype","text":"Retrieves the mimetype of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description str Mimetype of the image. Source code in wagtail_live/receivers/base.py def get_image_mimetype ( self , image ): \"\"\" Retrieves the mimetype of an image. Args: image (dict): Informations about an image Returns: str: Mimetype of the image. \"\"\" raise NotImplementedError","title":"get_image_mimetype()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_image_name","text":"Retrieves the name of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description str Name of the image. Source code in wagtail_live/receivers/base.py def get_image_name ( self , image ): \"\"\" Retrieves the name of an image. Args: image (dict): Informations about an image Returns: str: Name of the image. \"\"\" raise NotImplementedError","title":"get_image_name()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_image_title","text":"Retrieves the title of an image. Parameters: Name Type Description Default image dict Informations about an image required Returns: Type Description str Title of the image. Source code in wagtail_live/receivers/base.py def get_image_title ( self , image ): \"\"\" Retrieves the title of an image. Args: image (dict): Informations about an image Returns: str: Title of the image. \"\"\" raise NotImplementedError","title":"get_image_title()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_live_page_from_channel_id","text":"Retrieves the live page with a given channel ID. Parameters: Name Type Description Default channel_id str Channel ID required Returns: Type Description LivePageMixin The livepage corresponding to channel_id . Exceptions: Type Description Http404 if a page with the given channel_id doesn't exist. Source code in wagtail_live/receivers/base.py def get_live_page_from_channel_id ( self , channel_id ): \"\"\" Retrieves the live page with a given channel ID. Args: channel_id (str): Channel ID Returns: LivePageMixin: The livepage corresponding to `channel_id`. Raises: Http404: if a page with the given `channel_id` doesn't exist. \"\"\" return self . model . objects . get ( channel_id = channel_id )","title":"get_live_page_from_channel_id()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_message_files","text":"Retrieves the files of a message. A message is made of text and files. Parameters: Name Type Description Default message dict A received message from a messaging app required Returns: Type Description list Files included in the given message. Source code in wagtail_live/receivers/base.py def get_message_files ( self , message ): \"\"\" Retrieves the files of a message. A message is made of text and files. Args: message (dict): A received message from a messaging app Returns: list: Files included in the given message. \"\"\" raise NotImplementedError","title":"get_message_files()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_message_files_from_edited_message","text":"Retrieves the files from an edited message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description list Files of the edited message. Source code in wagtail_live/receivers/base.py def get_message_files_from_edited_message ( self , message ): \"\"\" Retrieves the files from an edited message. Args: message (dict): A received message from a messaging app. Returns: list: Files of the edited message. \"\"\" raise NotImplementedError","title":"get_message_files_from_edited_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_message_id_from_edited_message","text":"Retrieves the ID of the original message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description str ID of the original message that is being edited. Source code in wagtail_live/receivers/base.py def get_message_id_from_edited_message ( self , message ): \"\"\" Retrieves the ID of the original message. Args: message (dict): A received message from a messaging app. Returns: str: ID of the original message that is being edited. \"\"\" raise NotImplementedError","title":"get_message_id_from_edited_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_message_id_from_message","text":"Retrieves message's ID. Parameters: Name Type Description Default message dict A received message from a messaging app required Returns: Type Description str Id of the given message Source code in wagtail_live/receivers/base.py def get_message_id_from_message ( self , message ): \"\"\" Retrieves message's ID. Args: message (dict): A received message from a messaging app Returns: str: Id of the given message \"\"\" raise NotImplementedError","title":"get_message_id_from_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_message_text","text":"Retrieves the text of a message. A message is made of text and files. Parameters: Name Type Description Default message dict A received message from a messaging app required Returns: Type Description str Text of the given message. Source code in wagtail_live/receivers/base.py def get_message_text ( self , message ): \"\"\" Retrieves the text of a message. A message is made of text and files. Args: message (dict): A received message from a messaging app Returns: str: Text of the given message. \"\"\" raise NotImplementedError","title":"get_message_text()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.get_message_text_from_edited_message","text":"Retrieves the text an edited message. Parameters: Name Type Description Default message dict A received message from a messaging app. required Returns: Type Description str Text of the edited message. Source code in wagtail_live/receivers/base.py def get_message_text_from_edited_message ( self , message ): \"\"\" Retrieves the text an edited message. Args: message (dict): A received message from a messaging app. Returns: str: Text of the edited message. \"\"\" raise NotImplementedError","title":"get_message_text_from_edited_message()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.parse_text","text":"Parses a raw text content according to the input source formatting rules. Parameters: Name Type Description Default text str a text. required Returns: Type Description str the actual content of the text. (Returns the text itself by default). Source code in wagtail_live/receivers/base.py def parse_text ( self , text ): \"\"\" Parses a raw text content according to the input source formatting rules. Args: text (str): a text. Returns: str: the actual content of the text. (Returns the text itself by default). \"\"\" return text","title":"parse_text()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.process_files","text":"Processes the files of a message. Creates the corresponding block for any file and adds it to the given live post. Parameters: Name Type Description Default live_post LivePostBlock Live post to update. required files list Files to add to a live post. required Source code in wagtail_live/receivers/base.py def process_files ( self , live_post , files ): \"\"\" Processes the files of a message. Creates the corresponding block for any file and adds it to the given live post. Args: live_post (LivePostBlock): Live post to update. files (list): Files to add to a live post. \"\"\" for item in files : image_title = self . get_image_title ( image = item ) try : image_width , image_height = self . get_image_dimensions ( image = item ) except ValueError : logger . error ( f \"Unable to retrieve the dimensions of { image_title } \" ) continue mime_type = self . get_image_mimetype ( image = item ) if mime_type not in SUPPORTED_MIME_TYPES : logger . error ( f \"Couldn't upload { image_title } . \" + f \"Images of type { mime_type } aren't supported yet.\" ) continue image = get_image_model ()( title = image_title , width = image_width , height = image_height , ) image_content = self . get_image_content ( image = item ) image_name = self . get_image_name ( image = item ) image . file . save ( name = image_name , content = image_content , save = True ) block = construct_image_block ( image = image ) add_block_to_live_post ( block_type = IMAGE , block = block , live_block = live_post , )","title":"process_files()"},{"location":"reference/receivers/base-message-receiver/#wagtail_live.receivers.base.BaseMessageReceiver.process_text","text":"Processes the text of a message. Parses the message, constructs corresponding block types i.e Embed or Text and add those blocks to the given live post. Parameters: Name Type Description Default live_post LivePostBlock Live post to update. required message_text str Text to add to a live post. required Source code in wagtail_live/receivers/base.py def process_text ( self , live_post , message_text ): \"\"\" Processes the text of a message. Parses the message, constructs corresponding block types i.e Embed or Text and add those blocks to the given live post. Args: live_post (LivePostBlock): Live post to update. message_text (str): Text to add to a live post. \"\"\" message_parts = message_text . split ( \" \\n \" ) for text in message_parts : # Avoid creating a block for empty content text = text . strip () if not text : continue block_type = \"\" url = self . get_embed ( text = text ) if url : block = construct_embed_block ( url = url ) block_type = EMBED else : text_content = self . parse_text ( text = text ) block = construct_text_block ( text = text_content ) block_type = TEXT add_block_to_live_post ( block_type = block_type , block = block , live_block = live_post , )","title":"process_text()"},{"location":"reference/receivers/slack/","text":"Slack wagtail_live.receivers.slack.receivers.SlackWebhookMixin Slack WebhookMixin. post ( self , request , * args , ** kwargs ) Checks if Slack is trying to verify our Request URL. Returns: Type Description HttpResponse containing the challenge string if Slack is trying to verify our request URL. Source code in wagtail_live/receivers/slack/receivers.py def post ( self , request , * args , ** kwargs ): \"\"\" Checks if Slack is trying to verify our Request URL. Returns: HttpResponse: containing the challenge string if Slack is trying to verify our request URL. \"\"\" payload = json . loads ( request . body . decode ( \"utf-8\" )) if payload [ \"type\" ] == \"url_verification\" : return HttpResponse ( payload [ \"challenge\" ], content_type = \"plain/text\" ) return super () . post ( request , * args , ** kwargs ) set_webhook () classmethod This is done in Slack UI. Source code in wagtail_live/receivers/slack/receivers.py @classmethod def set_webhook ( cls ): \"\"\"This is done in Slack UI.\"\"\" pass sign_slack_request ( content ) staticmethod Signs content from a Slack request using the SLACK_SIGNING_SECRET as key. Source code in wagtail_live/receivers/slack/receivers.py @staticmethod def sign_slack_request ( content ): \"\"\"Signs content from a Slack request using the `SLACK_SIGNING_SECRET` as key.\"\"\" hasher = hmac . new ( str . encode ( settings . SLACK_SIGNING_SECRET ), digestmod = sha256 ) hasher . update ( str . encode ( content )) return hasher . hexdigest () verify_request ( self , request , body ) Verifies Slack requests. See: Verifying requests from Slack . Parameters: Name Type Description Default request HttpRequest from Slack required Exceptions: Type Description RequestVerificationError if request failed to be verified. Source code in wagtail_live/receivers/slack/receivers.py def verify_request ( self , request , body ): \"\"\" Verifies Slack requests. See: [Verifying requests from Slack](https://api.slack.com/authentication/ verifying-requests-from-slack). Args: request (HttpRequest): from Slack Raises: RequestVerificationError: if request failed to be verified. \"\"\" timestamp = request . headers . get ( \"X-Slack-Request-Timestamp\" ) if not timestamp : raise RequestVerificationError ( \"X-Slack-Request-Timestamp not found in request's headers.\" ) if abs ( time . time () - float ( timestamp )) > 60 * 5 : # The request timestamp is more than five minutes from local time. # It could be a replay attack, so let's ignore it. raise RequestVerificationError ( \"The request timestamp is more than five minutes from local time.\" ) sig_basestring = \"v0:\" + timestamp + \":\" + body my_signature = \"v0=\" + self . sign_slack_request ( content = sig_basestring ) slack_signature = request . headers [ \"X-Slack-Signature\" ] if not hmac . compare_digest ( slack_signature , my_signature ): raise RequestVerificationError ( \"Slack signature couldn't be verified.\" ) webhook_connection_set () classmethod Assume that it's true. Source code in wagtail_live/receivers/slack/receivers.py @classmethod def webhook_connection_set ( cls ): \"\"\"Assume that it's true.\"\"\" return True wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver Slack Events API receiver. dispatch_event ( self , event ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def dispatch_event ( self , event ): \"\"\"See base class.\"\"\" message = event [ \"event\" ] subtype = message . get ( \"subtype\" ) if subtype : if subtype == \"message_changed\" : self . change_message ( message = message ) elif subtype == \"message_deleted\" : self . delete_message ( message = message ) elif subtype == \"file_share\" : self . add_message ( message = message ) return self . add_message ( message = message ) get_channel_id_from_message ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_channel_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"channel\" ] get_embed ( self , text ) Slack sends url in this format: <https://twitter.com/wagtail/|https://twitter.com/wagtail/> where the first part is the full url and the second part represents the user's input. See Links in retrieved messages . Source code in wagtail_live/receivers/slack/receivers.py def get_embed ( self , text ): \"\"\" Slack sends url in this format: `<https://twitter.com/wagtail/|https://twitter.com/wagtail/>` where the first part is the full url and the second part represents the user's input. See [Links in retrieved messages](https://api.slack.com/reference/surfaces/ formatting#links-in-retrieved-messages). \"\"\" # Check if the text provided is a Slack-like url if text . startswith ( \"<\" ) and text . endswith ( \">\" ): # Get the url resolved by Slack url = text [ 1 : - 1 ] . split ( \"|\" )[ 0 ] if is_embed ( text = url ): return url return \"\" get_image_content ( self , image ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_content ( self , image ): \"\"\"See base class.\"\"\" slack_bot_token = getattr ( settings , \"SLACK_BOT_TOKEN\" , \"\" ) if not slack_bot_token : raise ImproperlyConfigured ( \"You haven't specified SLACK_BOT_TOKEN in your settings.\" + \"You won't be able to upload images from Slack without this setting defined.\" ) headers = { \"Authorization\" : f \"Bearer { slack_bot_token } \" } response = requests . get ( image [ \"url_private\" ], headers = headers ) return ContentFile ( response . content ) get_image_dimensions ( self , image ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_dimensions ( self , image ): \"\"\"See base class.\"\"\" try : return ( image [ \"original_w\" ], image [ \"original_h\" ]) except KeyError : raise ValueError get_image_mimetype ( self , image ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_mimetype ( self , image ): \"\"\"See base class.\"\"\" return image [ \"mimetype\" ] . split ( \"/\" )[ 1 ] get_image_name ( self , image ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_name ( self , image ): \"\"\"See base class.\"\"\" return image [ \"name\" ] get_image_title ( self , image ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_title ( self , image ): \"\"\"See base class.\"\"\" return image [ \"title\" ] get_message_files ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_files ( self , message ): \"\"\"See base class.\"\"\" return message [ \"files\" ] if \"files\" in message else [] get_message_files_from_edited_message ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_files_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_files ( message = message [ \"message\" ]) get_message_id_from_edited_message ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_id_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_id_from_message ( message = message [ \"previous_message\" ]) get_message_id_from_message ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"ts\" ] get_message_text ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_text ( self , message ): \"\"\"See base class.\"\"\" return message [ \"text\" ] get_message_text_from_edited_message ( self , message ) See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_text_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_text ( message = message [ \"message\" ]) parse_text ( self , text ) See Links in retrieved messages . See also base class. Source code in wagtail_live/receivers/slack/receivers.py def parse_text ( self , text ): \"\"\" See [Links in retrieved messages](https://api.slack.com/reference/surfaces/ formatting#links-in-retrieved-messages). See also base class. \"\"\" url_format = re . compile ( r \"<http([^|]+?)(\\|([^|]+?))?>\" ) urls = url_format . finditer ( text ) for url_match in urls : match = url_match . group ()[ 1 : - 1 ] if \"|\" in match : url , description = match . split ( \"|\" ) else : url = description = match try : validator = URLValidator () validator ( url ) except ValidationError : continue text = text . replace ( url_match . group (), f \"<a href=' { url } '> { description } </a>\" ) return text","title":"Slack"},{"location":"reference/receivers/slack/#slack","text":"","title":"Slack"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackWebhookMixin","text":"Slack WebhookMixin.","title":"SlackWebhookMixin"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackWebhookMixin.post","text":"Checks if Slack is trying to verify our Request URL. Returns: Type Description HttpResponse containing the challenge string if Slack is trying to verify our request URL. Source code in wagtail_live/receivers/slack/receivers.py def post ( self , request , * args , ** kwargs ): \"\"\" Checks if Slack is trying to verify our Request URL. Returns: HttpResponse: containing the challenge string if Slack is trying to verify our request URL. \"\"\" payload = json . loads ( request . body . decode ( \"utf-8\" )) if payload [ \"type\" ] == \"url_verification\" : return HttpResponse ( payload [ \"challenge\" ], content_type = \"plain/text\" ) return super () . post ( request , * args , ** kwargs )","title":"post()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackWebhookMixin.set_webhook","text":"This is done in Slack UI. Source code in wagtail_live/receivers/slack/receivers.py @classmethod def set_webhook ( cls ): \"\"\"This is done in Slack UI.\"\"\" pass","title":"set_webhook()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackWebhookMixin.sign_slack_request","text":"Signs content from a Slack request using the SLACK_SIGNING_SECRET as key. Source code in wagtail_live/receivers/slack/receivers.py @staticmethod def sign_slack_request ( content ): \"\"\"Signs content from a Slack request using the `SLACK_SIGNING_SECRET` as key.\"\"\" hasher = hmac . new ( str . encode ( settings . SLACK_SIGNING_SECRET ), digestmod = sha256 ) hasher . update ( str . encode ( content )) return hasher . hexdigest ()","title":"sign_slack_request()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackWebhookMixin.verify_request","text":"Verifies Slack requests. See: Verifying requests from Slack . Parameters: Name Type Description Default request HttpRequest from Slack required Exceptions: Type Description RequestVerificationError if request failed to be verified. Source code in wagtail_live/receivers/slack/receivers.py def verify_request ( self , request , body ): \"\"\" Verifies Slack requests. See: [Verifying requests from Slack](https://api.slack.com/authentication/ verifying-requests-from-slack). Args: request (HttpRequest): from Slack Raises: RequestVerificationError: if request failed to be verified. \"\"\" timestamp = request . headers . get ( \"X-Slack-Request-Timestamp\" ) if not timestamp : raise RequestVerificationError ( \"X-Slack-Request-Timestamp not found in request's headers.\" ) if abs ( time . time () - float ( timestamp )) > 60 * 5 : # The request timestamp is more than five minutes from local time. # It could be a replay attack, so let's ignore it. raise RequestVerificationError ( \"The request timestamp is more than five minutes from local time.\" ) sig_basestring = \"v0:\" + timestamp + \":\" + body my_signature = \"v0=\" + self . sign_slack_request ( content = sig_basestring ) slack_signature = request . headers [ \"X-Slack-Signature\" ] if not hmac . compare_digest ( slack_signature , my_signature ): raise RequestVerificationError ( \"Slack signature couldn't be verified.\" )","title":"verify_request()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackWebhookMixin.webhook_connection_set","text":"Assume that it's true. Source code in wagtail_live/receivers/slack/receivers.py @classmethod def webhook_connection_set ( cls ): \"\"\"Assume that it's true.\"\"\" return True","title":"webhook_connection_set()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver","text":"Slack Events API receiver.","title":"SlackEventsAPIReceiver"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.dispatch_event","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def dispatch_event ( self , event ): \"\"\"See base class.\"\"\" message = event [ \"event\" ] subtype = message . get ( \"subtype\" ) if subtype : if subtype == \"message_changed\" : self . change_message ( message = message ) elif subtype == \"message_deleted\" : self . delete_message ( message = message ) elif subtype == \"file_share\" : self . add_message ( message = message ) return self . add_message ( message = message )","title":"dispatch_event()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_channel_id_from_message","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_channel_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"channel\" ]","title":"get_channel_id_from_message()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_embed","text":"Slack sends url in this format: <https://twitter.com/wagtail/|https://twitter.com/wagtail/> where the first part is the full url and the second part represents the user's input. See Links in retrieved messages . Source code in wagtail_live/receivers/slack/receivers.py def get_embed ( self , text ): \"\"\" Slack sends url in this format: `<https://twitter.com/wagtail/|https://twitter.com/wagtail/>` where the first part is the full url and the second part represents the user's input. See [Links in retrieved messages](https://api.slack.com/reference/surfaces/ formatting#links-in-retrieved-messages). \"\"\" # Check if the text provided is a Slack-like url if text . startswith ( \"<\" ) and text . endswith ( \">\" ): # Get the url resolved by Slack url = text [ 1 : - 1 ] . split ( \"|\" )[ 0 ] if is_embed ( text = url ): return url return \"\"","title":"get_embed()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_image_content","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_content ( self , image ): \"\"\"See base class.\"\"\" slack_bot_token = getattr ( settings , \"SLACK_BOT_TOKEN\" , \"\" ) if not slack_bot_token : raise ImproperlyConfigured ( \"You haven't specified SLACK_BOT_TOKEN in your settings.\" + \"You won't be able to upload images from Slack without this setting defined.\" ) headers = { \"Authorization\" : f \"Bearer { slack_bot_token } \" } response = requests . get ( image [ \"url_private\" ], headers = headers ) return ContentFile ( response . content )","title":"get_image_content()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_image_dimensions","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_dimensions ( self , image ): \"\"\"See base class.\"\"\" try : return ( image [ \"original_w\" ], image [ \"original_h\" ]) except KeyError : raise ValueError","title":"get_image_dimensions()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_image_mimetype","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_mimetype ( self , image ): \"\"\"See base class.\"\"\" return image [ \"mimetype\" ] . split ( \"/\" )[ 1 ]","title":"get_image_mimetype()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_image_name","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_name ( self , image ): \"\"\"See base class.\"\"\" return image [ \"name\" ]","title":"get_image_name()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_image_title","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_image_title ( self , image ): \"\"\"See base class.\"\"\" return image [ \"title\" ]","title":"get_image_title()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_message_files","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_files ( self , message ): \"\"\"See base class.\"\"\" return message [ \"files\" ] if \"files\" in message else []","title":"get_message_files()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_message_files_from_edited_message","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_files_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_files ( message = message [ \"message\" ])","title":"get_message_files_from_edited_message()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_message_id_from_edited_message","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_id_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_id_from_message ( message = message [ \"previous_message\" ])","title":"get_message_id_from_edited_message()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_message_id_from_message","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"ts\" ]","title":"get_message_id_from_message()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_message_text","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_text ( self , message ): \"\"\"See base class.\"\"\" return message [ \"text\" ]","title":"get_message_text()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.get_message_text_from_edited_message","text":"See base class. Source code in wagtail_live/receivers/slack/receivers.py def get_message_text_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_text ( message = message [ \"message\" ])","title":"get_message_text_from_edited_message()"},{"location":"reference/receivers/slack/#wagtail_live.receivers.slack.receivers.SlackEventsAPIReceiver.parse_text","text":"See Links in retrieved messages . See also base class. Source code in wagtail_live/receivers/slack/receivers.py def parse_text ( self , text ): \"\"\" See [Links in retrieved messages](https://api.slack.com/reference/surfaces/ formatting#links-in-retrieved-messages). See also base class. \"\"\" url_format = re . compile ( r \"<http([^|]+?)(\\|([^|]+?))?>\" ) urls = url_format . finditer ( text ) for url_match in urls : match = url_match . group ()[ 1 : - 1 ] if \"|\" in match : url , description = match . split ( \"|\" ) else : url = description = match try : validator = URLValidator () validator ( url ) except ValidationError : continue text = text . replace ( url_match . group (), f \"<a href=' { url } '> { description } </a>\" ) return text","title":"parse_text()"},{"location":"reference/receivers/telegram/","text":"Telegram wagtail_live.receivers.telegram.receivers.TelegramWebhookMixin Telegram WebhookMixin. set_webhook () classmethod Sets webhook connection with Telegram's API Source code in wagtail_live/receivers/telegram/receivers.py @classmethod def set_webhook ( cls ): \"\"\"Sets webhook connection with Telegram's API\"\"\" response = requests . get ( get_base_telegram_url () + \"setWebhook\" , params = { \"url\" : get_telegram_webhook_url (), \"allowed_updates\" : [ \"message\" , \"edited_message\" , \"channel_post\" , \"edited_channel_post\" , ], }, ) payload = response . json () if not response . ok or not payload [ \"ok\" ]: raise WebhookSetupError ( \"Failed to set Webhook connection with Telegram's API. \" + f \" { payload [ 'description' ] } \" ) verify_request ( self , request , body , token , * args , ** kwargs ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def verify_request ( self , request , body , token , * args , ** kwargs ): \"\"\"See base class.\"\"\" if token != get_telegram_bot_token (): raise RequestVerificationError webhook_connection_set () classmethod See base class. Source code in wagtail_live/receivers/telegram/receivers.py @classmethod def webhook_connection_set ( cls ): \"\"\"See base class.\"\"\" response = requests . get ( get_base_telegram_url () + \"getWebhookInfo\" ) if response . ok : # Ensure that the webhook is set with the correct URL payload = response . json () return ( payload [ \"ok\" ] and payload [ \"result\" ][ \"url\" ] == get_telegram_webhook_url () ) return False wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver Telegram webhook receiver. add_image_to_message ( self , message ) Telegram sends images uploaded in a message one by one. Source code in wagtail_live/receivers/telegram/receivers.py def add_image_to_message ( self , message ): \"\"\"Telegram sends images uploaded in a message one by one.\"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_message ( message = message ) live_post = live_page . get_live_post_by_message_id ( message_id = message_id ) files = self . get_message_files ( message = message ) self . process_files ( live_post = live_post . value , files = files ) live_page . update_live_post ( live_post = live_post ) dispatch_event ( self , event ) Note : Telegram doesn't send an update when a message is deleted. See also base class. Source code in wagtail_live/receivers/telegram/receivers.py def dispatch_event ( self , event ): \"\"\" **Note**: Telegram doesn't send an update when a message is deleted. See also base class. \"\"\" for edit_type in [ \"edited_message\" , \"edited_channel_post\" ]: if edit_type in event : self . change_message ( message = event . get ( edit_type )) return message = event . get ( \"message\" ) or event . get ( \"channel_post\" ) if \"media_group_id\" in message : try : self . add_image_to_message ( message = message ) return except KeyError : pass if \"entities\" in message and message [ \"entities\" ][ 0 ][ \"type\" ] == \"bot_command\" : self . handle_bot_command ( message = message ) return self . add_message ( message = message ) get_channel_id_from_message ( self , message ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_channel_id_from_message ( self , message ): \"\"\"See base class.\"\"\" # Since live posts aren't cleaned when they are added via a receiver, # we make sure at this level that we return the correct types. return str ( message [ \"chat\" ][ \"id\" ]) get_file_path ( self , file_id ) Retrieves the file_path of a Telegram file. The file_path is necessary to have more infos about the image and to download it. Parameters: Name Type Description Default file_id str Id of the file to download. required Returns: Type Description str The file_path property of the file as sent by Telegram. Source code in wagtail_live/receivers/telegram/receivers.py def get_file_path ( self , file_id ): \"\"\" Retrieves the `file_path` of a Telegram file. The `file_path` is necessary to have more infos about the image and to download it. Args: file_id (str): Id of the file to download. Returns: str: The `file_path` property of the file as sent by Telegram. \"\"\" response = requests . get ( get_base_telegram_url () + \"getFile\" , params = { \"file_id\" : file_id } ) return response . json ()[ \"result\" ][ \"file_path\" ] get_image_content ( self , image ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_content ( self , image ): \"\"\"See base class.\"\"\" file_path = image [ \"file_path\" ] response = requests . get ( f \"https://api.telegram.org/file/bot { get_telegram_bot_token () } / { file_path } \" ) return ContentFile ( response . content ) get_image_dimensions ( self , image ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_dimensions ( self , image ): \"\"\"See base class.\"\"\" return image [ \"width\" ], image [ \"height\" ] get_image_mimetype ( self , image ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_mimetype ( self , image ): \"\"\"See base class.\"\"\" mimetype = image [ \"file_path\" ] . split ( \"/\" )[ - 1 ] . split ( \".\" )[ - 1 ] return \"jpeg\" if mimetype == \"jpg\" else mimetype get_image_name ( self , image ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_name ( self , image ): \"\"\"See base class.\"\"\" return image [ \"file_path\" ] . split ( \"/\" )[ - 1 ] get_image_title ( self , image ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_title ( self , image ): \"\"\"See base class.\"\"\" return image [ \"file_path\" ] . split ( \"/\" )[ - 1 ] . split ( \".\" )[ 0 ] get_message_files ( self , message ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_files ( self , message ): \"\"\"See base class.\"\"\" if \"photo\" in message : # Choose original photo which is the last of the list photo = message [ \"photo\" ][ - 1 ] photo [ \"file_path\" ] = self . get_file_path ( file_id = photo [ \"file_id\" ]) return [ photo ] return [] get_message_files_from_edited_message ( self , message ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_files_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_files ( message = message ) get_message_id_from_edited_message ( self , message ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_id_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_id_from_message ( message = message ) get_message_id_from_message ( self , message ) Messages containing multiple images have a media_group_id attribute. See also base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_id_from_message ( self , message ): \"\"\" Messages containing multiple images have a `media_group_id` attribute. See also base class. \"\"\" msg_id = message . get ( \"media_group_id\" ) or message . get ( \"message_id\" ) return str ( msg_id ) get_message_text ( self , message ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_text ( self , message ): \"\"\"See base class.\"\"\" # Telegram parses the text of a message before sending it. # The result can be found in the message's \"entities\". return { \"text\" : message . get ( \"text\" ) or message . get ( \"caption\" ) or \"\" , \"entities\" : message . get ( \"entities\" , []), } get_message_text_from_edited_message ( self , message ) See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_text_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_text ( message = message ) handle_bot_command ( self , message ) Handles the following bot commands: /get_chat_id : returns the id of the current chat. Source code in wagtail_live/receivers/telegram/receivers.py def handle_bot_command ( self , message ): \"\"\" Handles the following bot commands: - `/get_chat_id`: returns the id of the current chat. \"\"\" command = message [ \"entities\" ][ 0 ] start = command [ \"offset\" ] end = start + command [ \"length\" ] command_text = message [ \"text\" ][ start : end ] if command_text == \"/get_chat_id\" : chat_id = self . get_channel_id_from_message ( message = message ) response = requests . get ( get_base_telegram_url () + \"sendMessage\" , params = { \"chat_id\" : chat_id , \"text\" : chat_id , }, ) payload = response . json () if not payload [ \"ok\" ]: logger . error ( payload [ \"description\" ]) process_text ( self , live_post , message_text ) Use the message entities to convert links. A raw link isn't converted by Telegram and a link with a description is sent as a text_link entity. See also base class. Source code in wagtail_live/receivers/telegram/receivers.py def process_text ( self , live_post , message_text ): \"\"\" Use the message entities to convert links. A raw link isn't converted by Telegram and a link with a description is sent as a `text_link` entity. See also base class. \"\"\" text = message_text [ \"text\" ] len_text = len ( text ) entities = message_text [ \"entities\" ] # Process the entities in reversed order to be able to edit the text in place. for entity in reversed ( entities ): url = \"\" start = entity [ \"offset\" ] end = start + entity [ \"length\" ] if entity [ \"type\" ] == \"url\" : url = description = text [ start : end ] if is_embed ( url ): # Check if this can match an embed block, if so no conversion happens. # It matches an embed block if it has a line in the text for itself. if end == len_text or text [ end ] == \" \\n \" : if start == 0 or text [ start - 1 ] == \" \\n \" : # This is an embed block, skip to the next entity continue if entity [ \"type\" ] == \"text_link\" : url = entity [ \"url\" ] description = text [ start : end ] if url : url = format_url ( url ) link = f '<a href=\" { url } \"> { description } </a>' text = text [: start ] + link + text [ end :] return super () . process_text ( live_post = live_post , message_text = text )","title":"Telegram"},{"location":"reference/receivers/telegram/#telegram","text":"","title":"Telegram"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookMixin","text":"Telegram WebhookMixin.","title":"TelegramWebhookMixin"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookMixin.set_webhook","text":"Sets webhook connection with Telegram's API Source code in wagtail_live/receivers/telegram/receivers.py @classmethod def set_webhook ( cls ): \"\"\"Sets webhook connection with Telegram's API\"\"\" response = requests . get ( get_base_telegram_url () + \"setWebhook\" , params = { \"url\" : get_telegram_webhook_url (), \"allowed_updates\" : [ \"message\" , \"edited_message\" , \"channel_post\" , \"edited_channel_post\" , ], }, ) payload = response . json () if not response . ok or not payload [ \"ok\" ]: raise WebhookSetupError ( \"Failed to set Webhook connection with Telegram's API. \" + f \" { payload [ 'description' ] } \" )","title":"set_webhook()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookMixin.verify_request","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def verify_request ( self , request , body , token , * args , ** kwargs ): \"\"\"See base class.\"\"\" if token != get_telegram_bot_token (): raise RequestVerificationError","title":"verify_request()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookMixin.webhook_connection_set","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py @classmethod def webhook_connection_set ( cls ): \"\"\"See base class.\"\"\" response = requests . get ( get_base_telegram_url () + \"getWebhookInfo\" ) if response . ok : # Ensure that the webhook is set with the correct URL payload = response . json () return ( payload [ \"ok\" ] and payload [ \"result\" ][ \"url\" ] == get_telegram_webhook_url () ) return False","title":"webhook_connection_set()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver","text":"Telegram webhook receiver.","title":"TelegramWebhookReceiver"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.add_image_to_message","text":"Telegram sends images uploaded in a message one by one. Source code in wagtail_live/receivers/telegram/receivers.py def add_image_to_message ( self , message ): \"\"\"Telegram sends images uploaded in a message one by one.\"\"\" channel_id = self . get_channel_id_from_message ( message = message ) try : live_page = self . get_live_page_from_channel_id ( channel_id = channel_id ) except self . model . DoesNotExist : return message_id = self . get_message_id_from_message ( message = message ) live_post = live_page . get_live_post_by_message_id ( message_id = message_id ) files = self . get_message_files ( message = message ) self . process_files ( live_post = live_post . value , files = files ) live_page . update_live_post ( live_post = live_post )","title":"add_image_to_message()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.dispatch_event","text":"Note : Telegram doesn't send an update when a message is deleted. See also base class. Source code in wagtail_live/receivers/telegram/receivers.py def dispatch_event ( self , event ): \"\"\" **Note**: Telegram doesn't send an update when a message is deleted. See also base class. \"\"\" for edit_type in [ \"edited_message\" , \"edited_channel_post\" ]: if edit_type in event : self . change_message ( message = event . get ( edit_type )) return message = event . get ( \"message\" ) or event . get ( \"channel_post\" ) if \"media_group_id\" in message : try : self . add_image_to_message ( message = message ) return except KeyError : pass if \"entities\" in message and message [ \"entities\" ][ 0 ][ \"type\" ] == \"bot_command\" : self . handle_bot_command ( message = message ) return self . add_message ( message = message )","title":"dispatch_event()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_channel_id_from_message","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_channel_id_from_message ( self , message ): \"\"\"See base class.\"\"\" # Since live posts aren't cleaned when they are added via a receiver, # we make sure at this level that we return the correct types. return str ( message [ \"chat\" ][ \"id\" ])","title":"get_channel_id_from_message()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_file_path","text":"Retrieves the file_path of a Telegram file. The file_path is necessary to have more infos about the image and to download it. Parameters: Name Type Description Default file_id str Id of the file to download. required Returns: Type Description str The file_path property of the file as sent by Telegram. Source code in wagtail_live/receivers/telegram/receivers.py def get_file_path ( self , file_id ): \"\"\" Retrieves the `file_path` of a Telegram file. The `file_path` is necessary to have more infos about the image and to download it. Args: file_id (str): Id of the file to download. Returns: str: The `file_path` property of the file as sent by Telegram. \"\"\" response = requests . get ( get_base_telegram_url () + \"getFile\" , params = { \"file_id\" : file_id } ) return response . json ()[ \"result\" ][ \"file_path\" ]","title":"get_file_path()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_image_content","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_content ( self , image ): \"\"\"See base class.\"\"\" file_path = image [ \"file_path\" ] response = requests . get ( f \"https://api.telegram.org/file/bot { get_telegram_bot_token () } / { file_path } \" ) return ContentFile ( response . content )","title":"get_image_content()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_image_dimensions","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_dimensions ( self , image ): \"\"\"See base class.\"\"\" return image [ \"width\" ], image [ \"height\" ]","title":"get_image_dimensions()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_image_mimetype","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_mimetype ( self , image ): \"\"\"See base class.\"\"\" mimetype = image [ \"file_path\" ] . split ( \"/\" )[ - 1 ] . split ( \".\" )[ - 1 ] return \"jpeg\" if mimetype == \"jpg\" else mimetype","title":"get_image_mimetype()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_image_name","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_name ( self , image ): \"\"\"See base class.\"\"\" return image [ \"file_path\" ] . split ( \"/\" )[ - 1 ]","title":"get_image_name()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_image_title","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_image_title ( self , image ): \"\"\"See base class.\"\"\" return image [ \"file_path\" ] . split ( \"/\" )[ - 1 ] . split ( \".\" )[ 0 ]","title":"get_image_title()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_message_files","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_files ( self , message ): \"\"\"See base class.\"\"\" if \"photo\" in message : # Choose original photo which is the last of the list photo = message [ \"photo\" ][ - 1 ] photo [ \"file_path\" ] = self . get_file_path ( file_id = photo [ \"file_id\" ]) return [ photo ] return []","title":"get_message_files()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_message_files_from_edited_message","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_files_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_files ( message = message )","title":"get_message_files_from_edited_message()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_message_id_from_edited_message","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_id_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_id_from_message ( message = message )","title":"get_message_id_from_edited_message()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_message_id_from_message","text":"Messages containing multiple images have a media_group_id attribute. See also base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_id_from_message ( self , message ): \"\"\" Messages containing multiple images have a `media_group_id` attribute. See also base class. \"\"\" msg_id = message . get ( \"media_group_id\" ) or message . get ( \"message_id\" ) return str ( msg_id )","title":"get_message_id_from_message()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_message_text","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_text ( self , message ): \"\"\"See base class.\"\"\" # Telegram parses the text of a message before sending it. # The result can be found in the message's \"entities\". return { \"text\" : message . get ( \"text\" ) or message . get ( \"caption\" ) or \"\" , \"entities\" : message . get ( \"entities\" , []), }","title":"get_message_text()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.get_message_text_from_edited_message","text":"See base class. Source code in wagtail_live/receivers/telegram/receivers.py def get_message_text_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_text ( message = message )","title":"get_message_text_from_edited_message()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.handle_bot_command","text":"Handles the following bot commands: /get_chat_id : returns the id of the current chat. Source code in wagtail_live/receivers/telegram/receivers.py def handle_bot_command ( self , message ): \"\"\" Handles the following bot commands: - `/get_chat_id`: returns the id of the current chat. \"\"\" command = message [ \"entities\" ][ 0 ] start = command [ \"offset\" ] end = start + command [ \"length\" ] command_text = message [ \"text\" ][ start : end ] if command_text == \"/get_chat_id\" : chat_id = self . get_channel_id_from_message ( message = message ) response = requests . get ( get_base_telegram_url () + \"sendMessage\" , params = { \"chat_id\" : chat_id , \"text\" : chat_id , }, ) payload = response . json () if not payload [ \"ok\" ]: logger . error ( payload [ \"description\" ])","title":"handle_bot_command()"},{"location":"reference/receivers/telegram/#wagtail_live.receivers.telegram.receivers.TelegramWebhookReceiver.process_text","text":"Use the message entities to convert links. A raw link isn't converted by Telegram and a link with a description is sent as a text_link entity. See also base class. Source code in wagtail_live/receivers/telegram/receivers.py def process_text ( self , live_post , message_text ): \"\"\" Use the message entities to convert links. A raw link isn't converted by Telegram and a link with a description is sent as a `text_link` entity. See also base class. \"\"\" text = message_text [ \"text\" ] len_text = len ( text ) entities = message_text [ \"entities\" ] # Process the entities in reversed order to be able to edit the text in place. for entity in reversed ( entities ): url = \"\" start = entity [ \"offset\" ] end = start + entity [ \"length\" ] if entity [ \"type\" ] == \"url\" : url = description = text [ start : end ] if is_embed ( url ): # Check if this can match an embed block, if so no conversion happens. # It matches an embed block if it has a line in the text for itself. if end == len_text or text [ end ] == \" \\n \" : if start == 0 or text [ start - 1 ] == \" \\n \" : # This is an embed block, skip to the next entity continue if entity [ \"type\" ] == \"text_link\" : url = entity [ \"url\" ] description = text [ start : end ] if url : url = format_url ( url ) link = f '<a href=\" { url } \"> { description } </a>' text = text [: start ] + link + text [ end :] return super () . process_text ( live_post = live_post , message_text = text )","title":"process_text()"},{"location":"reference/receivers/webapp/","text":"Webapp wagtail_live.webapp.receiver.WebAppReceiver Webapp receiver. dispatch_event ( self , event ) See base class. Source code in wagtail_live/webapp/receiver.py def dispatch_event ( self , event ): \"\"\"See base class.\"\"\" message = event if message [ \"update_type\" ] == MESSAGE_EDITED : self . change_message ( message = message ) return elif message [ \"update_type\" ] == MESSAGE_DELETED : self . delete_message ( message = message ) return else : self . add_message ( message = message ) get_channel_id_from_message ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_channel_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"channel\" ] get_image_content ( self , image ) See base class. Source code in wagtail_live/webapp/receiver.py def get_image_content ( self , image ): \"\"\"See base class.\"\"\" return Image . objects . get ( id = image [ \"id\" ]) . image get_image_dimensions ( self , image ) See base class. Source code in wagtail_live/webapp/receiver.py def get_image_dimensions ( self , image ): \"\"\"See base class.\"\"\" return ( image [ \"image\" ][ \"width\" ], image [ \"image\" ][ \"height\" ]) get_image_mimetype ( self , image ) See base class. Source code in wagtail_live/webapp/receiver.py def get_image_mimetype ( self , image ): \"\"\"See base class.\"\"\" mime_type = image [ \"image\" ][ \"name\" ] . split ( \".\" )[ - 1 ] return \"jpeg\" if mime_type == \"jpg\" else mime_type get_image_name ( self , image ) See base class. Source code in wagtail_live/webapp/receiver.py def get_image_name ( self , image ): \"\"\"See base class.\"\"\" return image [ \"image\" ][ \"name\" ] get_image_title ( self , image ) See base class. Source code in wagtail_live/webapp/receiver.py def get_image_title ( self , image ): \"\"\"See base class.\"\"\" return image [ \"image\" ][ \"name\" ] . split ( \".\" )[ 0 ] . replace ( \"-\" , \" \" ) get_message_files ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_message_files ( self , message ): \"\"\"See base class.\"\"\" return message [ \"images\" ] get_message_files_from_edited_message ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_message_files_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_files ( message = message ) get_message_id_from_edited_message ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_message_id_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_id_from_message ( message = message ) get_message_id_from_message ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_message_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"id\" ] get_message_text ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_message_text ( self , message ): \"\"\"See base class.\"\"\" return message [ \"content\" ] get_message_text_from_edited_message ( self , message ) See base class. Source code in wagtail_live/webapp/receiver.py def get_message_text_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_text ( message = message )","title":"Webapp"},{"location":"reference/receivers/webapp/#webapp","text":"","title":"Webapp"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver","text":"Webapp receiver.","title":"WebAppReceiver"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.dispatch_event","text":"See base class. Source code in wagtail_live/webapp/receiver.py def dispatch_event ( self , event ): \"\"\"See base class.\"\"\" message = event if message [ \"update_type\" ] == MESSAGE_EDITED : self . change_message ( message = message ) return elif message [ \"update_type\" ] == MESSAGE_DELETED : self . delete_message ( message = message ) return else : self . add_message ( message = message )","title":"dispatch_event()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_channel_id_from_message","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_channel_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"channel\" ]","title":"get_channel_id_from_message()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_image_content","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_image_content ( self , image ): \"\"\"See base class.\"\"\" return Image . objects . get ( id = image [ \"id\" ]) . image","title":"get_image_content()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_image_dimensions","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_image_dimensions ( self , image ): \"\"\"See base class.\"\"\" return ( image [ \"image\" ][ \"width\" ], image [ \"image\" ][ \"height\" ])","title":"get_image_dimensions()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_image_mimetype","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_image_mimetype ( self , image ): \"\"\"See base class.\"\"\" mime_type = image [ \"image\" ][ \"name\" ] . split ( \".\" )[ - 1 ] return \"jpeg\" if mime_type == \"jpg\" else mime_type","title":"get_image_mimetype()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_image_name","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_image_name ( self , image ): \"\"\"See base class.\"\"\" return image [ \"image\" ][ \"name\" ]","title":"get_image_name()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_image_title","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_image_title ( self , image ): \"\"\"See base class.\"\"\" return image [ \"image\" ][ \"name\" ] . split ( \".\" )[ 0 ] . replace ( \"-\" , \" \" )","title":"get_image_title()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_message_files","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_message_files ( self , message ): \"\"\"See base class.\"\"\" return message [ \"images\" ]","title":"get_message_files()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_message_files_from_edited_message","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_message_files_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_files ( message = message )","title":"get_message_files_from_edited_message()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_message_id_from_edited_message","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_message_id_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_id_from_message ( message = message )","title":"get_message_id_from_edited_message()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_message_id_from_message","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_message_id_from_message ( self , message ): \"\"\"See base class.\"\"\" return message [ \"id\" ]","title":"get_message_id_from_message()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_message_text","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_message_text ( self , message ): \"\"\"See base class.\"\"\" return message [ \"content\" ]","title":"get_message_text()"},{"location":"reference/receivers/webapp/#wagtail_live.webapp.receiver.WebAppReceiver.get_message_text_from_edited_message","text":"See base class. Source code in wagtail_live/webapp/receiver.py def get_message_text_from_edited_message ( self , message ): \"\"\"See base class.\"\"\" return self . get_message_text ( message = message )","title":"get_message_text_from_edited_message()"},{"location":"reference/receivers/webhook_receiver_mixin/","text":"Webhook receiver mixin wagtail_live.receivers.base.WebhookReceiverMixin Mixin for receivers using the webhook technique. Attributes: Name Type Description url_path str Path of the URL used by a messaging app to send new updates to this receiver. url_name str Name of the URL for reversing/resolving. get_urls () classmethod Retrieves webhook urls after having ensured that a webhook connection is enabled with the corresponding messaging app. Returns: Type Description URLPattern URL which messaging apps use to send new updates. Exceptions: Type Description WebhookSetupError if the webhook connection with the messaging app didn't succeed. Source code in wagtail_live/receivers/base.py @classmethod def get_urls ( cls ): \"\"\" Retrieves webhook urls after having ensured that a webhook connection is enabled with the corresponding messaging app. Returns: URLPattern: URL which messaging apps use to send new updates. Raises: WebhookSetupError: if the webhook connection with the messaging app didn't succeed. \"\"\" if not cls . webhook_connection_set (): cls . set_webhook () return [ path ( cls . url_path , cls . as_view (), name = cls . url_name ), ] post ( self , request , * args , ** kwargs ) This is the main method for Webhook receivers. It handles new updates from messaging apps in these three steps: Verify the request. Dispatch the new event and process the updates received. Acknowledge the request. Parameters: Name Type Description Default request HttpRequest Http request required Returns: Type Description HttpResponse Forbidden if the request couldn't be verified. OK if the request is verified and updates have been succesfully processed. Source code in wagtail_live/receivers/base.py def post ( self , request , * args , ** kwargs ): \"\"\" This is the main method for Webhook receivers. It handles new updates from messaging apps in these three steps: 1. Verify the request. 2. Dispatch the new event and process the updates received. 3. Acknowledge the request. Args: request (HttpRequest): Http request Returns: HttpResponse: - `Forbidden` if the request couldn't be verified. - `OK` if the request is verified and updates have been succesfully processed. \"\"\" body = request . body . decode ( \"utf-8\" ) try : self . verify_request ( request , body , * args , ** kwargs ) except RequestVerificationError : return HttpResponseForbidden ( \"Request verification failed.\" ) self . dispatch_event ( event = json . loads ( body )) return HttpResponse ( \"OK\" ) set_webhook () classmethod Sets a webhook connection with the corresponding messaging app. This method may be trivial for messaging apps which propose setting a webhook in their UI like Slack. It may also be the main method if we have to set up the webhook connection ourselves; like with Telegram for example. Exceptions: Type Description WebhookSetupError if the webhook connection with the messaging app failed. Source code in wagtail_live/receivers/base.py @classmethod def set_webhook ( cls ): \"\"\" Sets a webhook connection with the corresponding messaging app. This method may be trivial for messaging apps which propose setting a webhook in their UI like Slack. It may also be the main method if we have to set up the webhook connection ourselves; like with Telegram for example. Raises: WebhookSetupError: if the webhook connection with the messaging app failed. \"\"\" raise NotImplementedError verify_request ( self , request , body , * args , ** kwargs ) Ensures that the incoming request comes from the messaging app expected. Parameters: Name Type Description Default request HttpRequest Http request required body str Body of the request required Exceptions: Type Description RequestVerificationError if the request verification failed Source code in wagtail_live/receivers/base.py def verify_request ( self , request , body , * args , ** kwargs ): \"\"\" Ensures that the incoming request comes from the messaging app expected. Args: request (HttpRequest): Http request body (str): Body of the request Raises: RequestVerificationError: if the request verification failed \"\"\" raise NotImplementedError webhook_connection_set () classmethod Checks if webhook a connection is set. We call this method before calling the set_webhook method in order to avoid sending unneccesary POST requests to the messaging app server. Returns: Type Description bool True if a webhook connection is set, False else. Source code in wagtail_live/receivers/base.py @classmethod def webhook_connection_set ( cls ): \"\"\" Checks if webhook a connection is set. We call this method before calling the `set_webhook` method in order to avoid sending unneccesary POST requests to the messaging app server. Returns: bool: - `True` if a webhook connection is set, - `False` else. \"\"\" raise NotImplementedError","title":"WebhookReceiverMixin"},{"location":"reference/receivers/webhook_receiver_mixin/#webhook-receiver-mixin","text":"","title":"Webhook receiver mixin"},{"location":"reference/receivers/webhook_receiver_mixin/#wagtail_live.receivers.base.WebhookReceiverMixin","text":"Mixin for receivers using the webhook technique. Attributes: Name Type Description url_path str Path of the URL used by a messaging app to send new updates to this receiver. url_name str Name of the URL for reversing/resolving.","title":"WebhookReceiverMixin"},{"location":"reference/receivers/webhook_receiver_mixin/#wagtail_live.receivers.base.WebhookReceiverMixin.get_urls","text":"Retrieves webhook urls after having ensured that a webhook connection is enabled with the corresponding messaging app. Returns: Type Description URLPattern URL which messaging apps use to send new updates. Exceptions: Type Description WebhookSetupError if the webhook connection with the messaging app didn't succeed. Source code in wagtail_live/receivers/base.py @classmethod def get_urls ( cls ): \"\"\" Retrieves webhook urls after having ensured that a webhook connection is enabled with the corresponding messaging app. Returns: URLPattern: URL which messaging apps use to send new updates. Raises: WebhookSetupError: if the webhook connection with the messaging app didn't succeed. \"\"\" if not cls . webhook_connection_set (): cls . set_webhook () return [ path ( cls . url_path , cls . as_view (), name = cls . url_name ), ]","title":"get_urls()"},{"location":"reference/receivers/webhook_receiver_mixin/#wagtail_live.receivers.base.WebhookReceiverMixin.post","text":"This is the main method for Webhook receivers. It handles new updates from messaging apps in these three steps: Verify the request. Dispatch the new event and process the updates received. Acknowledge the request. Parameters: Name Type Description Default request HttpRequest Http request required Returns: Type Description HttpResponse Forbidden if the request couldn't be verified. OK if the request is verified and updates have been succesfully processed. Source code in wagtail_live/receivers/base.py def post ( self , request , * args , ** kwargs ): \"\"\" This is the main method for Webhook receivers. It handles new updates from messaging apps in these three steps: 1. Verify the request. 2. Dispatch the new event and process the updates received. 3. Acknowledge the request. Args: request (HttpRequest): Http request Returns: HttpResponse: - `Forbidden` if the request couldn't be verified. - `OK` if the request is verified and updates have been succesfully processed. \"\"\" body = request . body . decode ( \"utf-8\" ) try : self . verify_request ( request , body , * args , ** kwargs ) except RequestVerificationError : return HttpResponseForbidden ( \"Request verification failed.\" ) self . dispatch_event ( event = json . loads ( body )) return HttpResponse ( \"OK\" )","title":"post()"},{"location":"reference/receivers/webhook_receiver_mixin/#wagtail_live.receivers.base.WebhookReceiverMixin.set_webhook","text":"Sets a webhook connection with the corresponding messaging app. This method may be trivial for messaging apps which propose setting a webhook in their UI like Slack. It may also be the main method if we have to set up the webhook connection ourselves; like with Telegram for example. Exceptions: Type Description WebhookSetupError if the webhook connection with the messaging app failed. Source code in wagtail_live/receivers/base.py @classmethod def set_webhook ( cls ): \"\"\" Sets a webhook connection with the corresponding messaging app. This method may be trivial for messaging apps which propose setting a webhook in their UI like Slack. It may also be the main method if we have to set up the webhook connection ourselves; like with Telegram for example. Raises: WebhookSetupError: if the webhook connection with the messaging app failed. \"\"\" raise NotImplementedError","title":"set_webhook()"},{"location":"reference/receivers/webhook_receiver_mixin/#wagtail_live.receivers.base.WebhookReceiverMixin.verify_request","text":"Ensures that the incoming request comes from the messaging app expected. Parameters: Name Type Description Default request HttpRequest Http request required body str Body of the request required Exceptions: Type Description RequestVerificationError if the request verification failed Source code in wagtail_live/receivers/base.py def verify_request ( self , request , body , * args , ** kwargs ): \"\"\" Ensures that the incoming request comes from the messaging app expected. Args: request (HttpRequest): Http request body (str): Body of the request Raises: RequestVerificationError: if the request verification failed \"\"\" raise NotImplementedError","title":"verify_request()"},{"location":"reference/receivers/webhook_receiver_mixin/#wagtail_live.receivers.base.WebhookReceiverMixin.webhook_connection_set","text":"Checks if webhook a connection is set. We call this method before calling the set_webhook method in order to avoid sending unneccesary POST requests to the messaging app server. Returns: Type Description bool True if a webhook connection is set, False else. Source code in wagtail_live/receivers/base.py @classmethod def webhook_connection_set ( cls ): \"\"\" Checks if webhook a connection is set. We call this method before calling the `set_webhook` method in order to avoid sending unneccesary POST requests to the messaging app server. Returns: bool: - `True` if a webhook connection is set, - `False` else. \"\"\" raise NotImplementedError","title":"webhook_connection_set()"}]}